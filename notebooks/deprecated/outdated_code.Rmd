---
title: "Not run: outdated code"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```








## Mixture modeling of Organoid size distribution


I estimate a log-gaussian mixture model of organoid size.

```{r, eval = TRUE}
library(mixtools)

df_mix <- normalmixEM(umap_df$size_log, k = 2)

df_fus <- df %>% dplyr::select(size_log) %>% mutate(posterior = "joined") %>% 
  rbind(data.frame(size_log = df_mix$x,
                   posterior = df_mix$posterior %>% as.data.frame() %>% round() %>% .$comp.1))

ggplot(df) + 
  geom_density(aes(x = size_log, y=..count..), alpha = 0.2) + 
  theme_cowplot()

ggplot(df_fus) + 
  geom_density(aes(x = size_log, y=..count.., fill = posterior), alpha = 0.2) + 
  theme_cowplot()
```

```{r, eval = TRUE}
df_mix
```



I scale this approach to all other organoid lines. 

```{r}
set.seed(0123349)

umap_mix <- umap_df %>% filter(drug == "DMSO")  %>% 
  nest(-line, -replicate) %>%
  mutate(mix_fit = map(data, ~ normalmixEM(.x$size_log, k = 2, maxit = 5000)),
         prob = map(mix_fit, ~ .x$posterior %>% as.data.frame() %>% .$comp.1)) 

umap_mix = umap_mix %>% unnest(prob, data) 
```

```{r}
set.seed(0.1)

df = umap_mix %>% mutate(posterior = round(prob)) %>% mutate(posterior = factor(posterior))

df %>% 
  sample_frac(0.01) %>%
  ggplot(aes(prob_dead, fill = posterior)) + 
  geom_histogram() + 
  scale_fill_brewer(type= "qual") + 
  scale_y_log10() + 
  theme_cowplot()

ggplot(df) + 
  geom_density(aes(x = size_log, fill = posterior, group = replicate), alpha = 0.5) + 
  facet_wrap(~ line) + 
  labs(caption = "Plotted are Replicates, DMSO treated organoids",
       x = "ln(size)") + 
  theme(legend.position = "bottom") +
  theme_cowplot()


ggplot(df) + 
  geom_density(aes(x = size_log, y=..count.., fill = posterior), alpha = 0.2) + 
  theme_cowplot() + 
  facet_wrap(~ line)
```

## Count distribution of Paclitaxel treated organoids 



```{r}
drug_count_param <- drug_count %>% 
  nest(-concentration, -line) %>% 
  mutate(fit = map(data, ~ fitdistrplus::fitdist(.x$n, "lnorm")))
        # param = map(fit, ~ .x$estimate %>% broom::tidy()))

drug_count_param %>% unnest(param) %>% 
  filter(names == "meanlog") %>%
  ggplot(aes(concentration, exp(x))) + 
    geom_point() + 
  theme_cowplot()
```


```{r}
drug_count_param %>% unnest(param) %>% 
  filter(names == "meanlog") %>% 
  dplyr::select(concentration, line, count = x) %>% 
  left_join(tram_size_param %>% unnest(param) %>% 
  filter(names == "meanlog") %>% dplyr::select(concentration, line, size = x)) %>% 
  
  ggplot(aes(count, size, color = concentration)) + 
  geom_point() + 
 # geom_path(aes(group = line)) +
  scico::scale_color_scico_d() + 
  theme_cowplot()


```




## Main Panel

```{r}
plot_grid(gg_size, 
          plot_grid(gg_line,
                    gg_bortezomib,
                    ncol = 2),
          labels = "AUTO",
          ncol = 2) + 
  gggsave(here::here("results/figures/panel_6.pdf"))
```

## Supplemental Panel

```{r}
plot_grid(gg_harmony_effect, 
          gg_size_supp,
          gg_size_dist
          )
```

## Running harmony on batches

We abandoned this approach as we did not screen organoid lines across batches. Reducing batch differences automatically led to a reduction of line specific effects. 


First, I illustrate batch effects and how they are reduced

```{r, eval = FALSE}
set.seed(123)

pca_metadata_frac <- pca_metadata %>% sample_frac(0.001)

pca_harmony <- pca_metadata_frac %>% dplyr::select(contains("V"))
metadata_harmony <- pca_metadata_frac %>% dplyr::select(screen_ID, Line)

my_harmony_embeddings <- HarmonyMatrix(
  pca_harmony, metadata_harmony, c("screen_ID"),
  do_pca = FALSE,
  verbose = TRUE, 
  return_object = TRUE
)

umap_pre <- uwot::umap(my_harmony_embeddings$Z_orig %>% t() %>% as_tibble(), verbose = TRUE)
umap_post <- uwot::umap(my_harmony_embeddings$Z_corr %>% t() %>% as_tibble(), verbose = TRUE)

harmony_effect <- umap_pre %>% as_tibble() %>% mutate(status = "pre") %>% cbind(id = 1:nrow(.)) %>% cbind(metadata_harmony)%>%
  rbind(.,umap_post %>% as_tibble() %>% mutate(status = "post")%>% cbind(id = 1:nrow(.)) %>% cbind(metadata_harmony)) 

harmony_effect %>% saveRDS(here::here("vignettes/07_organoid_unsupervised_exploration/harmony/harmony_effect.Rds"))
```

Here we can see the effect of Harmony on batch discordances.

```{r, eval = TRUE}
harmony_effect <- readRDS(here::here("vignettes/07_organoid_unsupervised_exploration/harmony/harmony_effect.Rds"))

gg_harmony_effect <- harmony_effect %>% 
  mutate(status = factor(status, levels = c("pre", "post"))) %>%
  ggplot(aes(V1, V2, color = screen_ID)) + 
  geom_point_rast(alpha = 0.5, size = 0.35) + 
  theme_cowplot() + 
  scale_color_brewer(type = "qual", palette = 2) +
  facet_wrap( ~ status) + 
  #ggsave(here::here("vignettes/07_organoid_unsupervised_exploration/pre_post_harmony.png")) + 
  NULL
```

Still, line-specific differences are conserved in this method.

```{r}
harmony_effect %>% 
 filter(status == "post") %>%
  ggplot(aes(V1, V2, color = screen_ID)) + 
  geom_point_rast(alpha = 0.5, size = 0.35) + 
  theme_cowplot() + 
  facet_wrap( ~ Line) + 
  scale_color_brewer(type = "qual") +
  #ggsave(here::here("vignettes/07_organoid_unsupervised_exploration/post_harmony_line.png")) + 
  NULL
```


## Running Harmony on replicate and on replicate+line level

```{r, eval = FALSE}
set.seed(123)

pca_harmony <- pca_metadata %>% dplyr::select(contains("V"))
metadata_harmony <- pca_metadata %>% dplyr::select(screen_ID, Line)

harmony_id <- HarmonyMatrix(
  pca_harmony, metadata_harmony, c("screen_ID"),
  do_pca = FALSE,
  verbose = TRUE, 
  return_object = TRUE
)

harmony_id$Z_corr %>% saveRDS(here::here("vignettes/07_organoid_unsupervised_exploration/harmony/harmony_pca_id.Rds"))
```

I load the Harmony results.

```{r, eval = FALSE}
harmony_id_corr <- readRDS(here::here("vignettes/07_organoid_unsupervised_exploration/harmony/harmony_pca_id.Rds"))
```



## Running harmony on both line and batch 

```{r, eval = FALSE}
harmony_id_line <- HarmonyMatrix(
  pca_harmony, metadata_harmony, c("screen_ID", "Line"),
  do_pca = FALSE,
  verbose = TRUE, 
  return_object = TRUE
)


harmony_id_line %>% saveRDS(here::here("vignettes/07_organoid_unsupervised_exploration/harmony/harmony_pca_id_line.Rds"))

```

## Individual Pseudotimes


```{r, eval = FALSE}
set.seed(123)

drug_order <- umap_df %>%
  dplyr::select(drug) %>%
    filter(grepl(drug, pattern = "__")) %>% .$drug %>% unique() %>% sort()

curve_df <- umap_df %>%
    filter(drug %in% drug_order) %>%
  mutate(drug = factor(drug, levels =drug_order)) %>% 
  arrange((drug)) %>% 
  group_by(drug, line) %>%
  sample_n(1000, replace = TRUE) %>% # adjust based on pan-line vs. line level 
  ungroup() %>% 
  # running the princcurve algorithm
  separate(drug, c("compound", "concentration"), sep = "__", remove = FALSE) %>%
  nest(-compound, -line) %>%
  #head(10) %>% 
  mutate(plot = purrr::map(data, ~ create_princurve_trace(.x)))

curve_df %>% saveRDS(here::here("vignettes/07_organoid_unsupervised_exploration/curve_df.Rds"))
```


```{r, eval = FALSE}
set.seed(123)

drug_order <- umap_df %>%
  dplyr::select(drug) %>%
    filter(grepl(drug, pattern = "__")) %>% .$drug %>% unique() %>% sort()

curve_df <- umap_df %>%
    filter(drug %in% drug_order) %>%
  mutate(drug = factor(drug, levels =drug_order)) %>% 
  arrange((drug)) %>% 
  group_by(drug, line) %>%
  sample_n(1000, replace = TRUE) %>% # adjust based on pan-line vs. line level 
  ungroup() %>% 
  # running the princcurve algorithm
  separate(drug, c("compound", "concentration"), sep = "__", remove = FALSE) %>%
  nest(-compound, -line) %>%
  #head(10) %>% 
  mutate(plot = purrr::map(data, ~ create_princurve_trace(.x)))

curve_df %>% saveRDS(here::here("vignettes/07_organoid_unsupervised_exploration/curve_df.Rds"))
```


```{r, eval = FALSE}
gg_curve_df <- curve_df %>% 
  mutate(compound_line = paste0(compound, "__", line)) %>%
  mutate(plot_trace = purrr::map(plot, ~ .x$fit %>% .[, ])) %>% 
  unnest(plot_trace) 

gg_curve_df %>%
  ggplot(aes(v1, v2)) + 
  geom_point(data = curve_df %>% unnest(data),
             aes(color = compound), alpha = 0.05, size = 0.35) +
  
  geom_path(aes(group = compound_line, color = compound_line), size = 1.5, arrow = arrow(angle = 10, ends = "last", type = "closed", length = unit(0.15, "inches"))) + 
  
  facet_grid(~ compound) +
   
  theme_cowplot() +
  labs(x = "UMAP 1",
       y = "UMAP 2")+
  theme(legend.position = "bottom")
```

## Plotting gigantic overview figure


```{r, eval = FALSE}
gg_line_overview <- plot_cells(ods, color_cells_by="morphological_class",
           alpha = 0.05, label_cell_groups = FALSE,
           rasterize = TRUE) + 
  facet_wrap(~ Line) + 
  theme(legend.position = "nothing") + 
  scale_color_manual(values = rev(c("#A2549B", "#D80D12", "#6E1614","#69B563", "#A9CEE1","#1E3B87"))) 
```

I directly write this supplementary plot to disc. 

```{r, eval = FALSE}
gg_line_overview + 
  ggsave(here("results/figures/single_organoid/line.pdf"), height = 8, width = 8)
```

## Running princurve on principle component data 


 In the past, I estimated a princurve directly from the UMAP embedding. I am not sure this is a good idea. Rather, I am going to test running the princurve algorithm on a set of PCs. 
What is the %-Variance explained per PC?

```{r}
vars_pca <- apply(reducedDims(ods)$PCA, 2, var)
vars_pca_scaled = vars_pca/sum(vars_pca)

vars_pca_scaled %>% plot()
```

This is the PCA-based princurve function. 

```{r}
create_princurve_trace_pca <- function(df){
  df_tmp_init <- df %>% 
  group_by(drug) %>% 
  summarise_at(vars(contains("pc")), funs(mean)) %>%
  ungroup()
  
  fit <- principal_curve(x = df %>% dplyr::select(pc1:pc5) %>% as.matrix(),
                       start = df_tmp_init %>% dplyr::select(pc1:pc5) %>% as.matrix(),
                       approx_points = FALSE, 
                       trace = TRUE, 
                       plot_iterations = FALSE, 
                       maxit = 30,
                       stretch =2)
  
  plot(fit)
  points(df_tmp_init%>% dplyr::select(pc1:pc5) %>% as.matrix())

  result <- list()
  
  result$fit <- fit$s[fit$ord,] %>% as_tibble()
  result$center <- df_tmp_init
  result$input <- df
  
  return(result)
}
```


```{r}
set.seed(123)

drug_order <- pca_tidy %>%
  dplyr::select(drug) %>%
    filter(grepl(drug, pattern = "__")) %>% .$drug %>% unique() %>% sort()

curve_df <- pca_tidy %>%
    filter(drug %in% drug_order) %>%
  mutate(drug = factor(drug, levels =drug_order)) %>% 
  arrange((drug)) %>% 
  group_by(drug, line) %>%
  sample_n(1000, replace = TRUE) %>% # adjust based on pan-line vs. line level 
  ungroup() %>% 
  # running the princcurve algorithm
  separate(drug, c("compound", "concentration"), sep = "__", remove = FALSE) %>%
  nest(-compound, -line) %>%
  head(1) %>% 
  mutate(plot = purrr::map(data, ~ create_princurve_trace_pca(.x)))
```


```{r}
set.seed(123)

gg_curve_df <- curve_df %>% 
  mutate(compound_line = paste0(compound, "__", line)) %>%
  mutate(plot_trace = purrr::map(plot, ~ .x$fit %>% .[, ])) %>% 
  unnest(plot_trace) 

pca_subset = pca_tidy %>% sample_frac(.01)
sample_index = pca_subset$uuid


curve_index = FNN::get.knnx(data = pca_subset %>% dplyr::select(pc1:pc5) %>% as.matrix(), gg_curve_df %>% dplyr::select(pc1:pc5) %>% as.matrix(), k=1, algorithm=c("kd_tree"))

gg_curve_df = cbind(gg_curve_df, umap_df %>% filter(uuid %in% sample_index) %>% .[curve_index$nn.index,] %>% dplyr::select(v1, v2))

gg_curve_df %>%
  ggplot(aes(v1, v2)) + 
  geom_point(data = curve_df %>% unnest(data) %>% dplyr::select(compound, line, uuid) %>% left_join(umap_df %>% dplyr::select(uuid, v1, v2)),
             aes(color = compound), alpha = 0.05, size = 0.35) +
  
  #geom_path(aes(group = compound_line, color = compound_line), size = 1.5, arrow = arrow(angle = 10, ends = "last", type = "closed", length = unit(0.15, "inches"))) + 
  geom_point(aes(group = compound_line, color = compound_line), size = 1.5) +
  #facet_grid(~ compound) +
  facet_wrap(~ compound_line) +
  theme_cowplot() +
  labs(x = "UMAP 1",
       y = "UMAP 2")+
  theme(legend.position = "bottom")
```


