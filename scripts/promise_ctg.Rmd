---
title: "CTG data analysis of HC1092 human organoid screen"
author: "Niklas Rindtorff"
output: 
   BiocStyle::html_document2:
    code_folding: hide
    df_print: paged
    toc_depth: 4
    toc_float: true
    fig_height: 6
    fig_width: 9.5
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction
12 organoid lines were screened with about 70 compounds (5 concentrations) of the clinical cancer panel. After 7 days total (4 days of treatment) the organoids we lysed and a ctg assay was performed. The experiment was conducted in 2 replciates. 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=8, fig.height=8) 
setwd("/Users/rindtorf/promise") #ugly hack
```

## Prepare data analysis
Load necessary packages for data analysis
```{r load-packages, message=FALSE, warning=FALSE}
#library(tidyverse)
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(corrr)
library(pheatmap)
library(gridExtra)
library(EBImage) #cite
library(HTSvis) #cite
library(PharmacoGx) #cite
library(growthcurve) #cite
library(jsonlite)
library(httr)
library(openxlsx)
library(preprocessCore)
library(stringr)
library(GRmetrics)
library(scales)
```

Load clinical data. The primary location of tumors is divided into three sights. 
```{r}
#import clinical data
cohort <- read_excel("~/promise/local_data/clinical_data/Clin_Data_Basic-cohort.xlsx") %>%
  separate(ID, c("p", "no.line"), sep = 1) %>%
  mutate(line = paste0("D", no.line, "T01")) %>% #only works if there were no re-biopsies
  select(-p, -no.line)

cohort_short <- cohort %>%
  #select(line, Location) %>%
  select(line, age, Location, `T`, N, M, Stage, G) %>%
  mutate(Patient = line) %>%
  select(-line)

cohort_short$Location[cohort_short$Location == "Asc"] <- "Right"
cohort_short$Location[cohort_short$Location == "Sigm"] <- "Left"

cohort_short <- cohort_short %>%
  mutate(Location = factor(Location, levels = c("Right", "Left", "Rectum")))
```

## Normalize CTG photon counts by a plates DMSO controls

### Validation of different normalization strategies

Appropriate normalization of CTG photon counts is key to ensure robust quantification of drug response. Many different strategies are available to remove potential technical bias from the data and some of them might be more appropriate than others depending on the kinds of bias present in the data. Hence, we examine carefully the kinds of technical bias present in our data set and employ different normalization strategies in order to correct these. We assess and compare performance of these different strategies by looking at various controls.

#### Assessment of technical bias present in the data

```{r, results='hide', warning=F, message=F}
##read ctg data files
ctg_data <- lapply(list.files('~/promise/rsync_data/ctg_data/HC1092/', full.names=T), 
                   function(f) read_tsv(f, col_names=F, col_types = 'cci') %>%
                     `colnames<-`(c('screen', 'well', 'pcount'))) %>% bind_rows()
```

For now we load again the plate annotation and merge that to the data to know which drug at which concentration went where.

```{r, results='hide', warning=F, message=F}
## read excel file, convert to tibble
plate_anno <- tbl_df(read.xlsx('~/promise/rsync_data/layouts/raw_layout_files/Clin_Cancer_Panel_V170511.xlsx'))
## rename drug and well columns
colnames(plate_anno)[c(1, 6)] <- c('drug', 'well')
## join with ctg data
ctg_data <- ctg_data %>% inner_join(plate_anno) %>% 
  extract(well, c('row', 'col'), regex='([A-P])(\\d{2})', remove=F) %>% 
  mutate(row=match(row, LETTERS), col=as.integer(col))
```

There was a technical issue with one of the plates. Wells have to be flagged accordingly.

```{r, results='hide', warning=F, message=F}
ctg_data <- ctg_data %>% 
  mutate(pcount = ifelse(screen == '170502_NR_M2_D004T01P006L08' & 
                         (row %in% seq(1, 15, by=2)) & 
                         (col %in% 1:13), NA, pcount))
```

Now we can get an idea of what the data looks like. First we look at only one plate at a time and look at the photon counts of DMSO controls to see how they vary and if there might be a positional bias that needs correction.

```{r, results='hide', warning=F, message=F}
## box plot of DMSO photon counts
ctg_data %>% filter(drug == 'DMSO') %>% 
  ggplot(aes(rack.concentration, pcount)) + geom_jitter(width=0.2) + 
  facet_wrap(~screen) + 
  geom_boxplot(alpha=0) + theme_classic()

## heat map of DMSO photon counts, ignoring other values
p <- ctg_data %>% filter(screen == unique(ctg_data$screen)[3])
p %>% mutate(pcount = ifelse(drug != 'DMSO', -1000, pcount)) %>% 
  dplyr::select(row, col, pcount) %>% spread(col, pcount) %>% 
  dplyr::select(-row) %>% as.matrix() %>% 
  pheatmap(cluster_rows=F, cluster_cols=F)
```

DMSO controls are scattered across the plate and there is no obvious spacial bias with the exception, maybe, of the control at the bottom right of the plate. However, some of the controls clearly failed and have to be flagged form the analysis. What is concerning is that these controls are all in the same area. Maybe plotting the plate as a whole reveals a spacial bias across all drugs.

```{r, results='hide', warning=F, message=F}
p %>% dplyr::select(row, col, pcount) %>% spread(col, pcount) %>% 
  dplyr::select(-row) %>% as.matrix() %>% 
  pheatmap(cluster_rows=F, cluster_cols=F)
```

I would say that there is definitely a spacial bias where photon counts get higher towards the bottom and the maybe edges of the plate.

```{r, results='hide', warning=F, message=F}
## scatter plot with robust loess fit for rows.
ctg_data %>% ggplot(aes(row, pcount)) + geom_point() + 
  geom_smooth(method.args=list(family='symmetric')) +
  facet_wrap(~screen) + theme_classic()

## scatter plot with robust loess fit for columns
ctg_data %>% ggplot(aes(col, pcount)) + geom_point() + 
  geom_smooth(method.args=list(family='symmetric')) +
  facet_wrap(~screen) + theme_classic()
```

#### Normlization of photon count data

Looking at above plots this seems to be true for rowwise effect but seems to be negligible on the x axis of the plates. Hence, in order we correct for row-wise spacial bias we apply a loess-normalization to the data.

```{r, results='hide', warning=F, message=F} 
## split data by plate and apply loess normalization
ctg_loess <- ctg_data %>% split(.$screen) %>% lapply(function(s){
  ## loess fit. family is 'symmetric' to be robust to outliers
  fit <- loess(pcount ~ row, data=s, family='symmetric')
  ## apply normalization
  s %>% mutate(norm_fac = predict(fit, row),
               pcount_norm = pcount - (norm_fac - median(norm_fac)))
}) %>% bind_rows()
```

```{r, results='hide', warning=F, message=F}
## plot row vs photon count of normalized values
ctg_loess %>% ggplot(aes(row, pcount_norm)) + geom_point() + 
  geom_smooth(method.args = list(family='symmetric')) + theme_classic() + 
  facet_wrap(~screen)
```

Next we can investigate plate specific biases and if correcting for these would actually change anything compared to just normalizing to the DMSO controls on every plate individually. We compare the effects by looking at the drug Bortezomib which we expect to be toxic regardless of the organoid line.

Of note, the 32 DMSO controls yield a reference median which is, across all plates, more robust and greater in relative size than a plate-wise median. Hence the DMSO control dependent median should be used for calibration of plates. 


```{r, results='hide', warning=F, message=F}
## no cross-plate normalization
ctg_loess %>% 
  left_join(ctg_loess %>% filter(drug == 'DMSO') %>% group_by(screen) %>% 
              summarise(ctrl = median(pcount_norm, na.rm=T)) %>% ungroup()) %>% 
  group_by(screen) %>% mutate(rv = pcount_norm/ctrl) %>% ungroup() %>% 
  filter(drug %in% c('DMSO', 'Bortezomib')) %>% 
  ggplot(aes(screen, rv, colour=drug)) + geom_point() + 
  facet_wrap(~rack.concentration) + theme_classic() + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

Without cross-plate normalization we can see that the drug is toxic, especially at higher concentrations, but we can definitely see some variation. I'm not sure at this point whether this could be a real effect or whetehr there is variation for different reasons (such as varying growth rate) that is better normalized away. Let's see if a cross-plate normalization changes anything.

```{r, results='hide', warning=F, message=F}
## median photon count across all dmso controls of all plates
all_dmso <- ctg_loess %>% filter(drug == 'DMSO') %>% .$pcount_norm %>% median(na.rm=T)

## cross-plate normalization
ctg_pn <- ctg_loess %>% 
  left_join(ctg_loess %>% filter(drug == 'DMSO') %>% group_by(screen) %>% 
                summarise(ctrl = median(pcount_norm, na.rm=T)) %>% ungroup()) %>% 
  group_by(screen) %>% mutate(pcn = pcount_norm * (all_dmso/ctrl)) %>% ungroup()
## plot bortezomib
ctg_pn %>% dplyr::select(-ctrl) %>%
    left_join(ctg_pn %>% filter(drug == 'DMSO') %>% group_by(screen) %>%
                  summarise(ctrl = median(pcn, na.rm=T)) %>% ungroup()) %>% 
    group_by(screen) %>% mutate(rv = pcn/ctrl) %>% ungroup() %>% 
  filter(drug %in% c('Bortezomib', 'DMSO')) %>% 
  ggplot(aes(screen, rv, colour=drug)) + geom_point() + 
  facet_wrap(~rack.concentration) + theme_classic() + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

So it seems that a cross plate normalization doesn't actually make a difference, indicating that the growth rates might be affecting the variation in phenotype mostly. Let's see if this could be adjusted using a quantile normalization.

```{r, results='hide', warning=F, message=F}
## generate a matrix with a column per sample and a row per well
ctg_mat <- ctg_loess %>% 
  left_join(ctg_loess %>% filter(drug == 'DMSO') %>% group_by(screen) %>% 
              summarise(ctrl = median(pcount_norm, na.rm=T)) %>% ungroup()) %>%
  group_by(screen) %>% mutate(pcount = pcount / ctrl) %>% ungroup() %>%
  dplyr::select(screen, well, pcount) %>% 
  spread(screen, pcount) %>% data.frame() %>% `rownames<-`(.$well) %>% 
  dplyr::select(-well)

## boxplot 
boxplot(ctg_mat)

## remember rownames and colnames
rn <- rownames(ctg_mat); cn <- colnames(ctg_mat)

## quantile normalize
qnorm_mat <- ctg_mat %>% as.matrix() %>% normalize.quantiles()
rownames(qnorm_mat) <- rn; colnames(qnorm_mat) <- cn

## boxplot of normalized matrix
boxplot(qnorm_mat)

## bring back together with the meta data
ctg_qnorm <- ctg_loess %>% dplyr::select(-c(pcount, pcount_norm, norm_fac)) %>% 
  inner_join(qnorm_mat %>% data.frame() %>% mutate(well = rownames(.)) %>% 
               tbl_df %>% gather(screen, pc_norm, -well) %>% 
               mutate(screen = gsub('^X', '', screen)))

## look at bortezomib
ctg_qnorm %>% filter(drug %in% c('Bortezomib', 'DMSO', 'Gefitinib')) %>% 
  ggplot(aes(screen, pc_norm, colour = drug)) + geom_point() + 
  facet_wrap(~rack.concentration) + theme_classic() + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

This looks reasonable to me. As a final check we can look at the 5-10 overall most toxic drugs and checkif there are differences between the lines (expecting that there are none).

```{r, results='hide', warning=F, message=F}
## select 5 most toxic drugs
dtox <- ctg_qnorm %>% group_by(drug) %>% 
  summarise(medpc = median(pc_norm, na.rm=T)) %>% ungroup() %>% 
  arrange(medpc) %>% .$drug %>% .[1:5]

## boxplot of these drugs across lines and concentrations
ctg_qnorm %>% filter(drug %in% dtox) %>% 
  ggplot(aes(screen, pc_norm)) + geom_boxplot() + 
  facet_wrap(~rack.concentration) + theme_classic() + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

I do not see anything that seems to really be strikingly off so I think it's ok to precede and calculate IC50/AUC values. Viability values of > 100 % do not really make sense as we wouldn't expect drug treatment to result in a gain of viability phenotype. Hence, we clip the values at 1 to achieve better AUC/IC50 models.

```{r, results='hide', warning=F, message=F}
ctg_qnorm <- ctg_qnorm %>% mutate(pc_norm = ifelse(pc_norm > 1, 1, pc_norm))
## histogram of normalized viability
hist(ctg_qnorm %>% .$pc_norm)
```

### Quantification of drug response

Different ways of quantifying drug response might yield different response. We first use the PharmacoGx package to calculate AUCs based on both the actual data and the fitted curve (I would assume the first to be more reasonable).

```{r, results='hide', warning = F, message=F, eval = FALSE}
## takes a while
auc_pgx <- ctg_qnorm %>%
   ## separate annotation of screen name 
  separate(screen, c("date", "operator", "mithras", "full_barcode"), remove = FALSE) %>%
  separate(full_barcode, c("line", "plate", "library"), remove = FALSE, sep = c(7, 11)) %>%
  group_by(screen, drug) %>% arrange(rack.concentration) %>% 
  ## calculate auc both for fitted curve and actual values
  mutate(s_AUC_fit = computeAUC(rack.concentration, pc_norm, verbose=F,
                              viability_as_pct = F, area.type = 'Fitted'), 
         s_AUC_actual = computeAUC(rack.concentration, pc_norm, verbose=F,
                                 viability_as_pct = F, area.type='Actual')) %>% 
  group_by(line, drug) %>% arrange(rack.concentration) %>% 
  ## calculate auc both for fitted curve and actual values
  mutate(l_AUC_fit = computeAUC(rack.concentration, pc_norm, verbose=F,
                              viability_as_pct = F, area.type = 'Fitted'), 
         l_AUC_actual = computeAUC(rack.concentration, pc_norm, verbose=F,
                                 viability_as_pct = F, area.type='Actual')) %>%
  ungroup()

save(auc_pgx, file = "auc_pgx.Rdata")
```

We plot a scatter plot to see if both ways of calculating the AUC agree. 

```{r, results='hide', warning=F, message=F, eval = FALSE}
load("~/promise/auc_pgx.Rdata")
auc_pgx %>% ggplot(aes(s_AUC_fit, s_AUC_actual)) + geom_point() + theme_classic()
auc_pgx %>% ggplot(aes(l_AUC_fit, l_AUC_actual)) + geom_point() + theme_classic()
```

It seems that they agree very well, with the exception of some outliers generated by cases with NAs. Looking through the results manually it seems that the values estimated by the fitted curve are more reasonable. It would be interesting to compare these results with the restults of a different AUC quantification, for example using a multilevel model.

### Evaluate growth-rate adjusted compound activity 

Next to quantile normalization, two recent papers suggest growth rate adjusted auc calculation to account for differences in doubling times of cell lines. 
First I load growth rate data from separate experiments and perform first annotation of the dataset. I filter the proliferation dataset further by removing empty wells.

```{r, message=FALSE, warning=FALSE}
#define datasets to load ctg data into R
filelist <- list.files("~/promise/rsync_data/ctg_data/proliferation_true", pattern = '_Prolif_', recursive = TRUE, full.names = TRUE)

#define a function to load proliferation ctg files into R once they match the given definitions
load_delim <- function(full.name){
  read_delim(full.name, 
    "\t", escape_double = FALSE, col_names = FALSE, 
    trim_ws = TRUE) %>% 
    mutate(plate_name = full.name %>% str_split(., "/") %>% .[[1]] %>% .[length(.)] %>% str_sub(.,1,-5))
}

#load ctg data
ctg_prolif_raw <- lapply(filelist, load_delim) %>% bind_rows() %>% `colnames<-` (c('original_name', 'well_id_384', 'photons', "plate_barcode")) %>%
  #ugly processing -it works
  separate(plate_barcode, c("tmp.plate_barcode", "tmp.mu"), sep = -7, remove = FALSE) %>%
  mutate(tmp.mu = substr(tmp.mu, 2,6)) %>%
  separate(tmp.mu, c("mithras", "user"), sep = "_") %>%
  separate(tmp.plate_barcode, c("date", "experiment", "timepoint", "lines" ), sep= "_", extra = "merge") %>%
  mutate(no_lines = str_count(lines, "D0")) %>%
  separate(well_id_384, c("letter", "number"), sep = 1, remove = FALSE) %>% 
  #data from seeding timepoints was generated in 96 well plates. For now it will be removed from the dataset to enable standardized analysis
  filter(! timepoint %in% c("seeding")) %>%
#on three dates (170613, 170724 and 171010) not the complete plate was filled with organoids. Here the unseeded wells are removed from the dataset. 
  filter(!(date %in% c("170613") & number %in% 13:24))%>%
  filter(!(date %in% c("170724") & number %in% 21:24))%>%
  filter(!(date %in% c("171010") & number %in% 19:24))%>%
#one single well in the dataset has a photon count of exactly 0 (second lowest value being 658). It is set to NA
  mutate(photons = replace(photons, which(photons == 0), NA))

#the data has the following distribution 
ctg_prolif_raw %>%
  ggplot(aes(photons)) + 
  geom_density(adjust = 0.3) + 
  scale_x_continuous(limits = c(0,50000)) + 
  theme_minimal() + 
  ggtitle("Distribution of Photon counts for all Proliferation Experiments")

```

I complete the annotation of the dataset by linking organoid lines to photon counts and time.

```{r, include=FALSE}
#get an overview of the lines and timepoints available. On each seeding-date there was only one set of lines processed and the plate-layout did not change between measurments.
#define a function to annotate a dataset for a defined seeding-date
annotate_prolif <- function(df){
  tmp.lines <- df %>% 
    select(lines) %>%
    .$lines %>% #turn output into a string
    unique() %>%
    str_split(., "_") %>%
    unlist()
  
  tmp.anno <- tibble(number = df %>% .$number %>%  unique(),
                     ratio = length(number)/length(tmp.lines),
                     anno_line = rep(tmp.lines, each = ratio),
                     no_lines = df %>% .$no_lines %>% unique(),
                      #for control reasons the product of the columsn per line and the number of lines is calculated
                     anno_number = no_lines*ratio) 
return(tmp.anno)
}

#redefine and annotate the ctg_prolif dataset
ctg_prolif <- ctg_prolif_raw %>%
  #filter(date == "171010") %>%
  group_by(date) %>%
  do(annotate_prolif(.)) %>%
  merge(ctg_prolif_raw, ., by = c("date", "number", "no_lines")) %>%
  filter(!(number %in% c(1,24) | letter %in% c("A", "P"))) %>%
  #wells loacted on the edge of the plates are removed. However, this filtration step has no impact on the median photon count per plate.  
  mutate(timepoint_num = substr(timepoint,2,2) %>% as.numeric(),
         photons_log2 = log2(photons)) %>%
  filter(!(date %in% c("170515", "170606"))) %>%
  filter((date != "170711") | (anno_line != "D015T01")) %>%
  #seeding-dates that contained a protocol-deviation are removed from the dataset
  dplyr::rename(line = anno_line) 

```

Gain a first overview about the proliferation dataset. Proliferation data for lines D015T01 and D030T01 appear discordant. Proliferation data for D019T01, D021T01 and D022T01 appear to follow a linear growth pattern

```{r, warning=FALSE}
ctg_prolif %>%
  group_by(date, timepoint_num, line) %>%
  summarise(median = median(photons, na.rm = TRUE),
            mad = mad(photons, na.rm = TRUE)) %>%
  ggplot(aes(timepoint_num, median, color = date)) +
  geom_point() +
  geom_path(aes(group = date)) +
  facet_wrap(~line) +
  theme_minimal() +
  ggtitle("Proliferation curves for 12 organoid lines") +
  ylab("Median photon count for each timepoint") +
  xlab("Time (d)")
```



```{r, warning=FALSE}
ctg_prolif %>% 
  select(timepoint_num, date, line, photons, photons_log2) %>%
  group_by(date, timepoint_num, line) %>%
  ggplot(aes(timepoint_num, photons_log2, group = date)) + 
  geom_jitter(alpha = 0.2, width = 0.2) + 
  stat_growthcurve(model = "linear") + 
  facet_wrap(~line) + 
  theme_minimal() + 
  scale_x_continuous(limits = c(2,4), breaks = c(2,4)) + 
  ggtitle("Proliferation curves for 12 organoid lines over 4 days") + 
  ylab("Log2 of median photon count for each timepoint") + 
  xlab("Time (d)") + 
  geom_smooth(alpha = 0.5)

#if multiple timepoints are estimated only these cell lines can be used, since they show log2 linear growth over all measured timepoints
picks <- c("D004T01", "D019T01", "D021T01", "D022T01")

fit <- ctg_prolif %>% 
  select(timepoint_num, date, line, photons_log2) %>%
  #filter(timepoint_num %in% c(2,4)) %>% #there is no difference when starting the model at t=2/t=0
  group_by(line, date) %>%
  do(fit_growth(df = ., time = timepoint_num, data = photons_log2, model = "linear") %>% broom::tidy()) %>%
  group_by(line, date) %>%
  summarise(`72` = estimate[1]+estimate[2]*3,
            #`96` = estimate[1]+estimate[2]*4,
            #`168` = estimate[1]+estimate[2]*7,
            m = estimate[2],
            b = estimate[1]) %>%
  gather(time, photons_log2, -m, -b, -line, -date) %>%
  mutate(time = time %>% as.numeric(),
         photons = 2^photons_log2,
         drug = "DMSO",
         full_barcode = paste0("PROLIF", line, date)) 
```

I tested that the estimation of doubling time is not considerably improved if positional effects are respected and every well is handled as a separate experiment.

```{r, eval = FALSE}
ctg_gr <- ctg_loess %>% 
  mutate(time = 168) %>%
  dplyr::rename(concentration = rack.concentration,
                photons = pcount) %>%
   ## separate annotation of screen name 
  separate(screen, c("date", "operator", "mithras", "full_barcode"), remove = FALSE) %>%
  separate(full_barcode, c("line", "plate", "library"), remove = FALSE, sep = c(7, 11)) %>%
  select(full_barcode, line, drug, time, concentration, photons) %>% 
  full_join(fit %>% select(line, time, photons, drug, full_barcode)) %>%
  #only lines which were still in a log phase of growth on the measured timepoints can be used for estimating the needed timepoints t=3 and t=7
  #filter(line %in% picks) %>%
  filter(line != "D015T01") %>%
  dplyr::rename(cell_count = photons,
                cell_line = line,
                treatment = drug) %>%
  as.tibble() %>%
  arrange(time)

# ctg_gr %>%
#   filter(cell_line %in% picks & treatment == "DMSO" & time == 168) %>%
#   ggplot(aes(full_barcode, cell_count)) +
#   geom_boxplot() +
#   facet_grid(~cell_line) + 
#   theme_minimal() + 
#   theme(axis.title.x=element_blank(),
#         axis.text.x=element_blank(),
#         axis.ticks.x=element_blank()) + 
#   ggtitle("Screen replicates and estimated viability at day 7") + 
#   ylab("Photon counts for DMSO treated wells")

drc_output <- ctg_gr %>% 
  select(-full_barcode) %>%
  mutate(concentration = if_else(treatment == "DMSO", "0", concentration),
         treatment = if_else(treatment == "DMSO", "-", treatment),
         concentration = as.numeric(concentration)) %>%
  mutate(time = time - 72) %>%
  GRfit(., case = "C", groupingVariables = c('cell_line','treatment'))
GRdrawDRC(drc_output, experiments = c(paste0(ctg_gr$cell_line %>% unique(), " ", "Volasertib")))

GRgetMetrics(drc_output) %>% 
  filter(pval_GR < 1) %>%
  select(cell_line, treatment, GR_AOC) %>%
  as.tibble() %>%
  ungroup() %>%
  dplyr::rename(line = cell_line,
         drug = treatment, 
         aoc.mean = GR_AOC) %>%
  filter(!drug %in% c( "DMSO")) %>%
  #filter(!line %in% c("D015T01", "D010T01")) %>%
  #filter(!grepl(.$drug, pattern = 'mit')) %>%
  spread(line, aoc.mean) %>%
  na.omit() %>%
  as.data.frame() %>%
  remove_rownames() %>%
  column_to_rownames('drug') %>%
  pheatmap( 
  #scale = "row",
  cluster_rows = TRUE,
  show_rownames = TRUE,
  show_colnames = TRUE,
  color = colorRampPalette(c('#ca0020','#f4a582','#f7f7f7', '#92c5de','#0571b0'))(5),
  #color = colorRampPalette(c('#f9f902','#000000','#3701f9'))(10),
  #color = c('#ca0020','#f4a582','#f7f7f7','#92c5de','#0571b0'),
  annotation_col = col,
  annotation_colors = ann_colors,
  #annotation_row = row
  #cutree_cols = 2,
  cutree_rows = 4,
  na_col = "grey"
  ) 

```

Compare AUC by the GRmetric package with the PharmacoGx analysis by correlating responses. First fit AUC data irrespective of timepoints.

```{r, eval=FALSE}
GRgetMetrics(drc_output) %>% 
  as.tibble() %>%
  ungroup() %>%
  dplyr::rename(line = cell_line,
         drug = treatment, 
         aoc.mean = GR_AOC)
  
auc_pgx
```

### Illustrate differences in growth rates

For future analysis it might be interesting to know the growth rate of each line as an additional feature. I will calculate a growth rate and attach it to the annotation data which we have previously defined for each organoid line. 

```{r}
fit %>%
  group_by(line) %>% 
  mutate(m_mean = mean(m)) %>%
  arrange((m_mean)) %>%
  ungroup(line) %>%
  mutate(line = factor(line, levels = line %>% unique())) %>%
ggplot() + 
  geom_point(aes(x=line, y=m_mean), col="black", size=5, alpha = 0.9) + #"tomato2"
  geom_point(aes(x=line, y=m), col="grey", size=2, alpha = 0.9) +   # Draw points
  geom_segment(aes(x=line, 
                   xend=line, 
                   y=min(m), 
                   yend=max(m)), 
               linetype="dashed", 
               size=0.1) +   # Draw dashed lines
  labs(title="Organoid Growth Rate", 
       subtitle="Cell doublings inbetween 48 and 96 hours after seeding") +  #caption
  coord_flip() + 
  theme_classic() + 
  xlab("Organoid line") + 
  ylab("Cell doublings in 48h")
```


```{r, eval = FALSE}
compound_of_interest <- c("Trifluoridin/Tipiracil")
dodge <- position_dodge(width=0.15)
ctg_qnorm %>%
  separate(screen, c("date", "operator", "mithras", "full_barcode"), remove = FALSE) %>%
  separate(full_barcode, c("line", "plate", "library"), remove = FALSE, sep = c(7, 11)) %>%
  filter(drug %in% compound_of_interest) %>%
  mutate(line = as.factor(line),
         drug = factor(drug, levels = compound_of_interest),
         concentration_factor = as.numeric(rack.concentration)) %>%
  group_by(line, drug, concentration_factor) %>%
     dplyr::summarise(mean_photons = mean(pc_norm, na.rm = TRUE),
                     sd_photons = sd(pc_norm, na.rm = TRUE),
                     range_low_photons = range(pc_norm)[1],
                     range_high_photons = range(pc_norm)[2]) %>%
    ggplot(aes(y = mean_photons, x = concentration_factor)) + 
    geom_point(position = dodge,  stat = "identity", aes( colour = line), size = 2)  + 
    geom_path(aes( colour = line), alpha = 0.6, position = dodge, size = 2) + 
    #geom_errorbar(aes(ymin=mean_photons-sd_photons, ymax=mean_photons+sd_photons, group = line), width=0, position = dodge, size = 1, alpha = 0.5) +
    #geom_ribbon( aes(x=concentration_factor, y=mean_photons, ymin=mean_photons-sd_photons, ymax=mean_photons+sd_photons), alpha=0.2) +
    scale_x_log10(breaks = c(7,14)) + 
    ylab("Photon count normalized to control") + 
    facet_wrap(~drug) + 
    xlab("Concentration factor 5-fold, mean of n=2") + 
    scale_colour_brewer(palette = "Set3") + 
    theme_minimal()
```

```{r}
```


# Session info 

```{r}
sessionInfo()
```
