---
title: "Molecular subtype classification of PROMISE organoid lines"
author: "Benedikt Rauscher"
date: "9/8/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, results='hide', warning=F, message=F, echo=F}
library(tidyverse)
library(affy)
library(CMSclassifier)
library(org.Hs.eg.db)
library(oligo)
library(preprocessCore)
library(pheatmap)
library(sva)
library(openxlsx)
```

# Aim of the analysis

Consensus molecular subtypes have recently been introduced for colorectal cancer (Guinney et al.) to divide cancer samples into logical groups with distinct molecular and functional characteristics. In order to determine these subtypes for the organoid lines of the PROMISE study, microarray experiments were performed for each line in two biological replicates. The following steps describe all steps from raw microarray data to final molecular subtype classification.

# Data preparation

In order to perform subtype classification a number of annotations is necessary that can help to link microarray probes to Entrez IDs required for subtype classification. The following code generate this mapping and in addition creates a list of reference genes whose expression will be required for the subtype classification.

```{r, results='hide', warning=F, message=F}
## id mapping derived from ENSEMBL biomart
id_mapping <- read_tsv('../data/meta/probe_mapping/hugene_mapping.txt')
id_mapping <- id_mapping %>% `colnames<-`(c('ensg', 'probe', 'symbol', 'dummy')) %>% 
  dplyr::select(-dummy)
x <- org.Hs.egSYMBOL
mapping_all <- as.list(x[mappedkeys(x)])
mapping_all <- cbind(names(mapping_all), mapping_all) %>% 
  tbl_df %>% `colnames<-`(c('entrez', 'symbol')) %>% unnest(symbol, entrez)
id_mapping <- id_mapping %>% inner_join(mapping_all) %>% drop_na() %>% distinct()

## U133 plus2 microarray probe annotation
id_mapping_u133 <- read_tsv('../data/meta/probe_mapping/affy_mapping2.txt') %>%
  dplyr::select(`Ensembl Gene ID`, `Affy HG U133-PLUS-2 probeset`) %>%
  `colnames<-`(c('ensg', 'probe')) %>%
  inner_join(id_mapping %>% dplyr::select(-probe))

## loading entrez gene ids to go into classifier (based on cmsclassify example data)
load('../data/meta/sample_data.Rdata')
refgene <- colnames(sampleData)
```

# Raw data normalization

Next, we need to load the raw data files and normalize them. We will use a combination of Robust Multi-Array Average (rma) for background correction and quantile normalization for expression level normalization. Experiments have been performed in three batches, where the Hugene platform was used for the first batch and the U133+2 platform was used for the other two batches.

## Batch 1: Hugene platform

```{r, results='hide', warning=F, message=F}
## read and normalize chip
orgas <- read.celfiles(filenames = list.files('../data/expression/organoids/PROMISE/', 
                                    pattern='HuGene.+CEL$', full.names = T))
norm_orgas <- rma(orgas)

## prepare expression data for classification
ex_p7_r1 <- data.frame(exprs(norm_orgas)) %>% 
  mutate(probe=rownames(.)) %>% tbl_df %>% 
  inner_join(id_mapping %>% mutate(probe=as.character(probe))) %>% 
  distinct()

## average technical replicates
ex_p7_r1 <- ex_p7_r1 %>% mutate(P7T_1 = rowMeans(ex_p7_r1[,1:3])) %>% .[,-(1:3)]
## gene level expression values with sample annotation
ex_p7_r1 <- ex_p7_r1 %>% group_by(symbol, entrez) %>% 
  summarise(expr = max(P7T_1)) %>% ungroup() %>% 
  mutate(sample = 'P7T_r1_Hugene')
```

## Batch 2: U133 plus 2 without Line 7

Here all organoid lines except for line 7 were microarrayed using the Affymetrix U133 plus2 platform.

```{r, results='hide', warning=F, message=F}
## read CEL files
orgas_b2 <- ReadAffy(filenames = list.files('../data/expression/organoids/PROMISE/', 
                                pattern='U133.+.CEL', full.names=T))
## calculate RMA corrected expression values
ex_r1 <- orgas_b2 %>% affy::rma() %>% exprs()
## convert to gene level values (long format)
ex_r1 <- ex_r1 %>% data.frame() %>% mutate(probe=rownames(.)) %>% tbl_df %>% 
  gather(sample, expr, -probe) %>% 
  inner_join(id_mapping_u133) %>% distinct() %>% 
  group_by(sample, symbol, entrez) %>% summarise(expr = max(expr)) %>% ungroup()
```

## Batch 3: U133 plus 2 all lines

All lines were processed on an Affymetrix U133 plus 2 platform. However, line 21 was submitted separated from the other lines which could introduce some technical variation.

```{r, results='hide', warning=F, message=F}
## file names of the CEL files
fn <- c(list.files('../data/expression/organoids/PROMISE/affy_chips01/', 
                   pattern='CEL', full.names=T), 
        list.files('../data/expression/organoids/PROMISE/affy_chips02/', 
                   pattern='CEL', full.names=T))

## read chips
orgas_b3 <- ReadAffy(filenames = fn)
## calculate RMA corrected expression values
ex_r2 <- orgas_b3 %>% affy::rma() %>% exprs()
## convert to gene level values (long format - same as above)
ex_r2 <- ex_r2 %>% data.frame() %>% mutate(probe=rownames(.)) %>% tbl_df %>% 
  gather(sample, expr, -probe) %>% 
  inner_join(id_mapping_u133) %>% distinct() %>% 
  group_by(sample, symbol, entrez) %>% summarise(expr = max(expr)) %>% ungroup()
```

# Integration of normalized data

Next we integrate data from all samples (one sample per biological replicate so in total 12*2) into a common matrix. We assess potential batch effects in the matrix and normalize accordingly. This is specifically important as, in addition to subtype classification, we also want to use this aggregated expression matrix to perform differential expression analyses of samples with interesting differences in drug response.

```{r, results='hide', warning=F, message=F}
## aggregate into commbon matrix. one row per gene and one column per sample
expr <- ex_p7_r1 %>% bind_rows(ex_r1 %>% mutate(sample=paste0(sample, '_r1'))) %>% 
  bind_rows(ex_r2 %>% mutate(sample=paste0(sample, '_r2')))
## to matrix, remove all entrez IDs only covered by the Hugene chip (> 90% NAs)
expr_mat <- expr %>% dplyr::select(-symbol) %>% spread(sample, expr) %>% 
  .[apply(., 1, function(x) sum(is.na(x))/length(x)) < 0.9,] %>%
  data.frame() %>% `rownames<-`(.$entrez) %>% dplyr::select(-entrez) %>% 
  as.matrix()
```

First we assess if expression values across samples are comparable. We would expect that gene expression is, on average, the same across all samples.

```{r, results='hide', warning=F, message=F}
par(las=1)
boxplot(expr_mat, horizontal=T)
```

There is definitely a difference between the two batches and the Hugene chip is a clear outlier. We quantile normalize to adjust this.

```{r, results='hide', warning=F, message=F}
rn <- rownames(expr_mat); cn <- colnames(expr_mat)
## quantile normalize
expr_norm <- normalize.quantiles(expr_mat)
rownames(expr_norm) <- rn; colnames(expr_norm) <- cn

##boxplot again
par(las=1)
boxplot(expr_norm, horizontal=T)
```

We next look at the rows with the highest standard deviation to assess batch effects that might be present in the data. We expect biological replicates to cluster together.

```{r, results='hide', warning=F, message=F}
pheatmap(expr_norm[order(apply(expr_norm, 1, sd))[1:1000],])
```

The Hugene experiment really doesn't fit to the others so we exclude that one for now. Looking at low variability genes we can appreciate some bias between the two batches which we could try to correct for using ComBat.

```{r, results='hide', warning=F, message=F}
## exclude Hugene experiment
expr_norm <- expr_norm[,colnames(expr_norm) != 'P7T_r1_Hugene']

## batch vector
batch <- as.factor(grepl('r1', colnames(expr_norm)))
## model matrix with only intercept (no covariate)
mm <- model.matrix(~1, data=data.frame(sample=colnames(expr_norm)))
## run ComBat on affymetrix part of the data set
expr_norm_bc <- ComBat(expr_norm, batch, mod=mm, prior.plots = T)
```

We examine the results via heat map.

```{r, results='hide', warning=F, message=F}
pheatmap(expr_norm_bc[order(apply(expr_norm_bc, 1, sd), decreasing=T)[1:1000],])
```

The results look reasonable good now, with most of the biological replicates clustering closely togther. Lines 20, 21 and 22 are not as well behaved as the others.

# Saving the expression data for donstream analysis

The normalized data can be used for downstream differential expression analysis. We therefore save them to a table in long data format after annotation of some possibly relevant variables.

```{r, results='hide', warning=F, message=F}
expr_long <- expr_norm_bc %>% data.frame() %>% mutate(entrez = rownames(.)) %>% 
  ## to long format
  tbl_df %>% gather(sample, expr, -entrez) %>% 
  ## add gene identifiers
  left_join(id_mapping_u133 %>% dplyr::select(symbol, entrez, ensg)) %>% distinct() %>% 
  mutate(rep = ifelse(grepl('r1', sample), 'rep1', 'rep2')) %>% 
  separate(sample, c('line', 'tag'), sep='_', extra='merge') %>% 
  dplyr::select(-tag) %>% 
  mutate(line = ifelse(grepl('^X', line), gsub('^X', 'P0', line), line),
         line = ifelse(line == 'P004T', 'P04T', line)) 

## save to table
write_tsv(expr_long, '../data/expression/organoids/PROMISE_gene_expression.tsv')
```

# Classification of molecular subtypes

Finally we select the relevant Entrez IDs and classify the molecular subtype of each line. We perform classification for biological replicates independently as a sanity check to get an idea of how robust the classification works.

```{r, results='hide', warning=F, message=F}
promise_cms <- classifyCMS.RF(data.frame(expr_norm[rownames(expr_norm) %in% refgene,])) %>% 
  mutate(sample=rownames(.)) %>% tbl_df %>% 
  mutate(rep = ifelse(grepl('r1', sample), 'rep1', 'rep2')) %>% 
    separate(sample, c('line', 'tag'), sep='_', extra='merge') %>% 
    dplyr::select(-tag) %>% 
    mutate(line = ifelse(grepl('^X', line), gsub('^X', 'P0', line), line),
           line = ifelse(line == 'P004T', 'P04T', line))

## write to file
write.xlsx(promise_cms, '../data/expression/organoids/PROMISE/PROMISE_CMS.xlsx')
```

# Session info

```{r}
sessionInfo()
```