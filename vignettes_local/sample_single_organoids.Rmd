---
title: "R Notebook"
output: html_notebook
---

# Setup

```{r}
library(tidyverse)
library(here)
#library(umap)
library(rhdf5) #needed for local data access
library(furrr) #needed for local data access
library(uwot)
library(cowplot)
library(naniar)
library(janitor)
library(dbscan)
#library(mvoutlier)

knitr::opts_chunk$set(chunk = TRUE)

# install.packages('devtools')
# devtools::install_github('VPetukhov/ggrastr')

#library(ggrastr)
```

First I define the data I am interested in. The whole dataset has a size of roughly 50GB. There is no way this data can fit in a memory for a single operation. 

For now I will resort to a sampling based approach. I will sample 1000 random DMSO treated organoids from each experiment.

```{r}
feature_path <- c("/home/rindtorf/data/rauscher/promise/PROMISE/data-10x-4t-c-16z/features")

hdf5_path_df <- tibble(path = list.files(feature_path, full.name = TRUE),
       bc = list.files(feature_path, full.name = FALSE)) %>%
  filter((grepl(x = path, pattern = "D0"))) %>% 
  mutate(hdf5_path = paste0(path, "/", bc, "_processedFeatures.h5")) %>% 
  # I remove every file that does not exist 
  mutate(exist = furrr::future_map(hdf5_path, ~ .x %>% file.exists)) %>% 
  unnest()

```

I open a single hdf5 object and access the structure.

```{r, eval = TRUE}
# only execute with access to large dataset
df <- hdf5_path_df[1,]

poi <- df$hdf5_path
h5ls(poi)
```

Let's dive in. I load 100 DMSO treated organoids per plate. I accept horrible I/O overhead right now. 

```{r, eval = FALSE}
h5closeAll()
time_punch <- microbenchmark::microbenchmark(
# I identify DMSO treated wells
hdf5_dmso <- df %>% 
  filter(exist == TRUE) %>%
  mutate(metadata = furrr::future_map(hdf5_path, ~ h5read(.x, "metadata_organoids") %>% 
                                 t() %>% 
                                 as_tibble() %>% 
                                 magrittr::set_colnames(h5read(poi, "metadata_names_organoids")))) %>% 
  mutate(features = furrr::future_map(hdf5_path, ~ h5read(.x, "features_organoids") %>%
                                        as_tibble())) %>%
  # merge dataframes and reduce size
  mutate(features_anno = map2(metadata, features, ~ cbind(.x, .y) %>% as_tibble() %>% 
                                              filter(Drug == "DMSO") %>%
                                              group_by(Field) %>% 
                                              sample_n(25) %>% 
                                ungroup()))
, times = 5)
h5closeAll()
```

I rewrite the function, because it is too slow. 

```{r, eval = FALSE}
h5closeAll()
time_pull <- microbenchmark::microbenchmark(
# I identify DMSO treated wells
hdf5_dmso <- df %>% 
  filter(exist == TRUE) %>%
  mutate(metadata = furrr::future_map(hdf5_path, ~ h5read(.x, "metadata_organoids") %>% 
                                 t() %>% 
                                 as_tibble() %>% 
                                 magrittr::set_colnames(h5read(poi, "metadata_names_organoids")) %>% 
                                 mutate(index = 1:nrow(.)) %>%
                                   filter(Drug == "DMSO") %>%
                                              group_by(Field) %>% 
                                              sample_n(25) %>% 
                                ungroup())) %>% 
  mutate(features = furrr::future_map2(hdf5_path, metadata, ~ h5read(.x, "features_organoids", index=list(.y$index, c(1:1571))) %>%
                                        as_tibble()))
, times = 5)
h5closeAll()
```

On average I save up to 800ms per operation and a ton of memory.

```{r, eval = FALSE}
set.seed(123)
h5closeAll()
# I identify DMSO treated wells
hdf5_dmso <- hdf5_path_df %>% 
  filter(exist == TRUE) %>%
  mutate(metadata = furrr::future_map(hdf5_path, ~ h5read(.x, "metadata_organoids") %>% 
                                 t() %>% 
                                 as_tibble() %>% 
                                 magrittr::set_colnames(h5read(poi, "metadata_names_organoids")) %>% 
                                 mutate(index = 1:nrow(.)) %>%
                                   filter(Drug == "DMSO") %>%
                                              group_by(Field) %>% 
                                              sample_n(100) %>% 
                                ungroup())) %>% 
  mutate(features = furrr::future_map2(hdf5_path, metadata, 
                                       ~ {h5read(.x, "features_organoids", index=list(.y$index, c(1:1571))) %>% as_tibble()}))
h5closeAll()

saveRDS(hdf5_dmso, here("hdf5_dmso_100.Rds")) #hdf5_dmso with only 25 objects per field
```

I load the dataset.

```{r, eval = TRUE}
hdf5_dmso <- readRDS(here("hdf5_dmso.Rds"))
```


As it turns out, a group of features is not completely represetned in our dataset. I remove features with missing values.

```{r}
hdf5_dmso_miss <- hdf5_dmso %>% 
  unnest(features) %>% 
  select(contains("V")) %>%
  #magrittr::set_colnames(h5read(poi, "feature_names_organoids")) %>%
  naniar::miss_var_summary()

hdf5_dmso_miss %>% 
  ggplot(aes(pct_miss)) + 
  geom_histogram()

keep_features <- hdf5_dmso_miss %>% filter(n_miss == 0) %>% .$variable

hdf5_dmso_filter <- hdf5_dmso %>% 
  unnest(features) %>% 
  select(contains("V")) %>%
  #magrittr::set_colnames(h5read(poi, "feature_names_organoids")) %>% 
  dplyr::select(keep_features)
```

Moreover, I remove features that have no detectable variance and are infinite. 

```{r}
inf_features <- hdf5_dmso_filter %>% 
  mutate_all(funs(max)) %>% distinct() %>% t() %>% as.data.frame() %>%
  tibble::rownames_to_column("feature") %>% janitor::clean_names() %>%
  filter(is.infinite(v1)) %>%
  .$feature
  

hdf5_dmso_filter_inf <- hdf5_dmso_filter %>% 
  dplyr::select(-inf_features)
```

Next, I visualize the data in a UMAP embedding and color by plate. I expect samples from the same line to group together.

I experiment iwth the features a bit. 

```{r, eval = FALSE}
feature_anno <- tibble(feature = hdf5_dmso_filter_inf %>% colnames()) %>% 
  separate(feature, c("x", "channel", "class", "name", "extra"), sep = "\\.", remove = FALSE)%>%
  mutate(contains_a = grepl(channel, pattern = "a", ignore.case = TRUE),
         contains_b = grepl(channel, pattern = "b", ignore.case = TRUE),
         contains_c = grepl(channel, pattern = "c", ignore.case = TRUE))

feature_a <- feature_anno %>% filter(contains_a == FALSE) %>% .$feature
feature_b <- feature_anno %>% filter(contains_b == FALSE) %>% .$feature
feature_c <- feature_anno %>% filter(contains_c == FALSE) %>% .$feature
```

I create a metadata table

```{r}
umap_dmso_100_meta <- hdf5_dmso %>% 
  unnest(features) %>% 
  select(-contains("V")) %>% 
  semi_join(hdf5_dmso, .) %>% 
  dplyr::select(metadata) %>% unnest(metadata) %>% 
  mutate(morphological_class = case_when(Line %in% c("D046T01",
                                                     "D054T01",
                                                     "D055T01") ~ "disorganized",
                                         Line %in% c("D018T01") ~ "organized",
                                         Line %in% c("D027T01",
                                                     "D013T01",
                                                     "D030T01") ~ "weakly organized",
                                         Line %in% c("D010T01",
                                                     "D007T01") ~ "weakly disorganized",
                                         Line %in% c("D004T01",
                                                     "D019T01",
                                                     "D020T01",
                                                     "D022T01") ~ "intermediate",
                                         Line %in% c("D018T01") ~ "organized",
                                         TRUE ~ "other") %>% factor(levels = c("organized", "weakly organized",
                                                                               "intermediate", "weakly disorganized",
                                                                               "disorganized", "other")))

```

I run an alternative UMAP version, called UWOT

```{r}
set.seed(123)
uwot_dmso_100 <- hdf5_dmso_filter_inf %>%
  # cbind(umap_dmso_100_meta) %>% 
  # filter(Line != "D010T01") %>%
  # mutate(Size = as.numeric(Size)) %>%
  # filter(Size > 1000) %>%
  #dplyr::select(-(Concentration:morphological_class)) %>%
  #dplyr::select(feaure_a) %>%
  uwot::umap(verbose = TRUE, 
             n_neighbors = 30,
             n_epochs = 200,
             metric = "hamming",
             min_dist = 0.1,
             ret_model = TRUE,
             ret_nn = TRUE)

#pca init not great
# supervised approaches not useful 
# minus a does not make sense
saveRDS(uwot_dmso_100, here("uwot_dmso_100.Rds"))
```

I plot the UWOT embedding 

```{r}
# I create a small function that centers the majority of the datapoints in the top-right corner of the embedding.
uwot_dmso_100_oriented <- uwot_dmso_100$embedding %>% 
  as.data.frame() %>%
  janitor::clean_names() %>%
  cbind(umap_dmso_100_meta) %>% as_tibble()

v1_center = median(uwot_dmso_100_oriented$v1)
v2_center = median(uwot_dmso_100_oriented$v2)

uwot_dmso_100_oriented <- uwot_dmso_100_oriented %>% 
  rowwise() %>%
  mutate(v1 = if_else(v1_center < 0, v1*(-1), v1),
         v2 = if_else(v2_center < 0, v2*(-1), v2))

uwot_dmso_100_oriented %>%
  # cbind(umap_dmso_100_meta %>% filter(Line != "D010T01") %>% 
  #         mutate(Size = as.numeric(Size)) %>%
  # filter(Size > 1000)) %>% 
  ggplot(aes(v1, v2, color = morphological_class)) + 
  geom_point(alpha = 0.1) + 
  #facet_wrap(morphological_class ~ Line) + 
  scale_color_manual(values = rev(c("#A2549B", "#D80D12", "#6E1614","#69B563", "#A9CEE1","#1E3B87"))) + 
  
  #geom_density2d(color = "black") + 
  theme_bw() +
  labs(x = "UMAP 1",
       y = "UMAP 2",
       caption = "control treated organoids") + 
  theme(legend.position = "None")
```

```{r}
uwot_dmso_100_oriented %>%
 # cbind(umap_dmso_100_meta %>% filter(Line != "D010T01") %>% 
 #          mutate(Size = as.numeric(Size)) %>%
 #  filter(Size > 1000)) %>% 
  mutate(Size = as.numeric(Size) %>% log()) %>%
  ggplot(aes(v1, v2, color = Size)) + 
  geom_point(alpha = 0.2) + 
  scale_color_viridis_c() +
  theme_bw() +
  labs(x = "UMAP 1",
       y = "UMAP 2",
       caption = "control treated organoids") + 
  theme(legend.position = "bottom") + 
  geom_density2d(color = "black") + 
  ggsave("uwot_all.pdf", width = 6, height =4)
```

I remove outliers using dbscan. 

```{r}
library(dbscan)
set.seed(123)
uwot_dmso_100_cluster_10 <- uwot_dmso_100$embedding %>% 
  as.data.frame() %>%
  janitor::clean_names() %>%
  hdbscan(., minPts = 10) #5 , 50, 10

saveRDS(uwot_dmso_100_cluster_10, here("uwot_dmso_100_cluster_10.Rds"))
```

CFLAGS="-I/usr/include" LDFLAGS="-lgsl -lgslcblas -lm" R

I visualize the cluster size 

```{r}
clusters_dmso <- tibble(cluster = uwot_dmso_100_cluster_10$cluster,
       outlier = uwot_dmso_100_cluster_10$outlier_scores) %>% 
  mutate(noise = cluster == 0) %>%
  mutate(cluster = factor(cluster) %>% fct_infreq()) 

# clusters_dmso %>%
#   ggplot(aes(cluster, fill = noise)) + 
#   geom_bar() + 
#   scale_y_log10() + 
#   theme_classic()# + 
#   #geom_hline()

clusters_dmso %>% 
  count(cluster) %>% 
  #mutate(cluster = cluster %>% as.character() %>% as.numeric()) %>%
  mutate(percent = 1-(n/sum(n))) %>% 
  mutate(noise = cluster == "0") %>%
  ggplot(aes(cluster, percent)) + 
  geom_point(aes(color = noise)) + 
  scale_y_continuous(limits = c(0,1)) + 
  theme_classic() + 
  #geom_path() + 
  scale_color_brewer(type = "qual") +
  geom_hline(yintercept = 0.90, linetype = "dashed") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        legend.position = "bottom") + 
  ggsave("cluster_cutoff.pdf", width = 6, height =4)
  
```

What blows my mind is that the method uses the hamming distance to create our embedding. This distance metric counts the number of perturbations required to change one feature vector into another. Basically, unless one feature is not exactly the same, the metric will always be 486 (the total number of features).

```{r}
hamming_dist <- e1071::hamming.distance(hdf5_dmso_filter_inf %>% head(4900) %>% as.matrix) %>% table()

hamming_dist %>% as_tibble() %>% set_colnames(c("distance", "n")) %>% 
  filter(distance != 0) %>% 
  ggplot(aes(distance, n)) + 
  geom_bar(stat = "identity") + 
  theme_classic() + 
  scale_y_log10()
```

Which features show the lowest variance? As features are not comparable, this is not particularly useful.

```{r}
hdf5_dmso_filter_inf %>% 
  mutate_all(function(x) (sd(x)/mean(x))^2) %>% 
  distinct() %>% 
  gather(feature, cov) %>% 
  arrange(desc(cov)) %>% 
  ggplot(aes(cov)) + 
  geom_histogram() + 
  scale_x_log10() + 
  theme_classic() + 
  geom_vline(xintercept = 1)
```

Certain features show extreme dispersion. Perhaps this is why extremely minimalist measures of distance rendered a more interpretable embedding.

```{r}
hdf5_dmso_filter_inf %>% 
  mutate_all(scale) %>% 
  mutate_all(function(x) range(x)[2]-range(x)[1]) %>% 
  distinct() %>% 
  gather(feature, range) %>% 
  arrange(desc(range)) %>% 
  ggplot(aes(range)) + 
  geom_histogram() + 
  theme_classic()
```


# Organoid DMSO Analysis

I mark the outliers and display the large central cluster organizing the majority of organoids.

```{r}
cluster_oi <- clusters_dmso %>% 
    count(cluster) %>% 
    mutate(cluster = cluster %>% as.character() %>% as.numeric()) %>% arrange(desc(n)) %>% filter(cluster != 0) %>%
  head(1) %>% 
  .$cluster

gg_size <- uwot_dmso_100_oriented %>%
  cbind(cluster = uwot_dmso_100_cluster_10$cluster) %>%
  filter(cluster != 0) %>%
  filter(cluster %in% c(cluster_oi)) %>%
 # cbind(umap_dmso_100_meta %>% filter(Line != "D010T01") %>% 
 #          mutate(Size = as.numeric(Size)) %>%
 #  filter(Size > 1000)) %>% 
  mutate(Size = as.numeric(Size) %>% log()) %>%
  ggplot(aes(v1, v2, color = Size)) + 
  geom_point(alpha = 0.5, size = 0.7) + 
  #geom_point_rast(alpha = 0.5, size = 0.7) +
  scale_color_viridis_c() +
  theme_classic() +
  labs(x = "UMAP 1",
       y = "UMAP 2") + 
  theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) +
  scale_x_continuous(breaks = c(-2, 0, 2)) 

gg_size +
  #guides(shape = guide_legend(override.aes = list(size = 0.5))) + 
  #guides(color = guide_legend(override.aes = list(size = 0.5))) +
  ggsave("uwot_size.pdf", width = 2, height =2.5)



```

```{r}
# I define the bounding box of the cluster I am interested in.
roi_dims <- uwot_dmso_100_oriented %>%
  cbind(cluster = uwot_dmso_100_cluster_10$cluster) %>%
  filter(cluster != 0) %>%
  filter(cluster %in% c(cluster_oi)) %>% 
  summarise(v1_max = max(v1),
            v1_min = min(v1),
            v2_max = max(v2),
            v2_min = min(v2))
```


50% of all DMSO treated organoids are located in this single cluster of objects. I visualize the location of specific lines. 

```{r}
gg_line <- uwot_dmso_100_oriented %>%
  cbind(cluster = uwot_dmso_100_cluster_10$cluster) %>%
  filter(cluster != 0) %>%
  filter(cluster %in% c(cluster_oi)) %>%
  ggplot(aes(v1, v2)) + 
  geom_point(alpha = 1, size = 0.7, color = "#f1f1f1") + 
  geom_point(data = uwot_dmso_100_oriented %>%
  cbind(cluster = uwot_dmso_100_cluster_10$cluster) %>%
  filter(cluster != 0) %>%
  filter(cluster %in% c(cluster_oi)) %>% 
    filter(Line %in% c("D055T01", "D018T01")),
  aes(color = Line),alpha = .5, size = 0.7) + 
  
  #facet_wrap(morphological_class ~ Line) + 
  scale_color_manual(values = rev(c("#D80D12", "#1E3B87"))) + 
  
  #geom_density2d(color = "black") + 
  theme_classic() +
  labs(x = "UMAP 1",
       y = "UMAP 2")+
       #caption = "control treated organoids") + 
  theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) +
  scale_x_continuous(breaks = c(-2, 0, 2)) 

gg_line +
  ggsave("uwot_single_organoid.pdf", width = 2, height = 2)
```


```{r}
uwot_dmso_100_oriented %>%
  cbind(cluster = uwot_dmso_100_cluster_10$cluster) %>%
  filter(cluster != 0) %>%
  filter(cluster %in% c(cluster_oi)) %>%
  ggplot(aes(v1, v2, color = morphological_class)) + 
  geom_point(alpha = 1, size = 0.7)+
  facet_wrap(~ Line) + 
  scale_color_manual(values = rev(c("#A2549B", "#D80D12", "#6E1614","#69B563", "#A9CEE1","#1E3B87"))) + 
  
  #geom_density2d(color = "black") + 
  theme_bw() +
  labs(x = "UMAP 1",
       y = "UMAP 2")+
       #caption = "control treated organoids") + 
  theme(legend.position = "None") + 
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) +
  scale_x_continuous(breaks = c(-2, 0, 2)) +
  ggsave("uwot_single_organoid_class.pdf", width = 8, height = 8)
```

# Build MST 

Create graph from distance object

```{r, eval = FALSE}
## from dynverse MST benchmark function 
# infer dimred
space <- dyndimred::dimred(expression, method = parameters$dimred, ndim = parameters$ndim)

# cluster cells
clust <- mclust::Mclust(space, modelNames = "EEV", G = 5:15)

centers <- t(clust$parameters$mean)

milestone_ids <- paste0("M", seq_len(nrow(centers)))
rownames(centers) <- milestone_ids

# convert distance to similarity
dis <- as.matrix(dist(centers))
rownames(dis) <- colnames(dis) <- milestone_ids

disdf <- dis %>%
  reshape2::melt(varnames = c("from", "to"), value.name = "weight") %>%
  na.omit()

# calculate mst
gr <- igraph::graph_from_data_frame(disdf, directed = FALSE, vertices = milestone_ids)
mst <- igraph::minimum.spanning.tree(gr, weights = igraph::E(gr)$weight)

milestone_network <-
  igraph::as_data_frame(mst) %>%
  transmute(from, to, length = weight, directed = FALSE)

```


```{r}
library(mclust)

space <- uwot_dmso_100_oriented %>%
  cbind(cluster = uwot_dmso_100_cluster_10$cluster) %>%
  filter(cluster != 0) %>%
  filter(cluster %in% c(cluster_oi)) %>% 
  dplyr::select(v1, v2)

  # cluster cells
clust <- mclust::Mclust(space, modelNames = "EEV", G = 1:10) #5-15 used to be default, tried 1-10

centers <- t(clust$parameters$mean)

milestone_ids <- paste0("M", seq_len(nrow(centers)))
rownames(centers) <- milestone_ids

# convert distance to similarity
dis <- as.matrix(dist(centers))
rownames(dis) <- colnames(dis) <- milestone_ids

disdf <- dis %>%
  reshape2::melt(varnames = c("from", "to"), value.name = "weight") %>%
  na.omit()

# calculate mst
gr <- igraph::graph_from_data_frame(disdf, directed = FALSE, vertices = milestone_ids)
mst <- igraph::minimum.spanning.tree(gr, weights = igraph::E(gr)$weight)

milestone_network <-
  igraph::as_data_frame(mst) %>%
  transmute(from, to, length = weight, directed = FALSE)

milestone_location <- centers %>% 
  as.data.frame() %>%
  rownames_to_column("milestone")

milestone_network_ggplot <- milestone_network %>% 
  dplyr::select(milestone = from, -length, -directed) %>% 
  left_join(milestone_location, by = "milestone") %>% 
  dplyr::select(-milestone) %>% 
  cbind(milestone_network %>% 
  dplyr::select(milestone = to, -length, -directed) %>%
  left_join(milestone_location, by = "milestone") %>% 
    dplyr::select(v1_to = v1, v2_to = v2))
  
```



# Trametinib induced shift

```{r, eval = FALSE}
h5closeAll()
# I identify DMSO treated wells
hdf5_mek <- hdf5_path_df[,] %>% 
  filter(exist == TRUE) %>%
  mutate(metadata = furrr::future_map(hdf5_path, ~ h5read(.x, "metadata_organoids") %>% 
                                 t() %>% 
                                 as_tibble() %>% 
                                 magrittr::set_colnames(h5read(poi, "metadata_names_organoids")) %>% 
                                 mutate(index = 1:nrow(.)) %>%
                                   filter(Drug %in% c("Selumetinib (AZD6244)", 
                                                      "Refametinib (RDEA119, Bay 86-9766)",
                                                      "Pimasertib (AS-703026)",
                                                      "AZD8330",
                                                      "DMSO")) %>%
                                              group_by(Drug) %>% 
                                              sample_n(25) %>% 
                                ungroup())) %>% 
  mutate(features = furrr::future_map2(hdf5_path, metadata, 
                                       ~ {h5read(.x, "features_organoids", index=list(.y$index, c(1:1571))) %>% as_tibble()}))
h5closeAll()

saveRDS(hdf5_mek, here("hdf5_mek.Rds"))
```

I load the MEK inhibitor treatment data and preprocess it. 

```{r}
hdf5_mek <- readRDS(here("hdf5_mek.Rds"))

hdf5_mek_filter_inf <- hdf5_mek %>%
  unnest(features) %>% 
  select(contains("V")) %>%
  #magrittr::set_colnames(h5read(poi, "feature_names_organoids")) %>% 
  dplyr::select(keep_features) %>%
  dplyr::select(-inf_features)
```

I predict the DMSO embedding

```{r}
# 
# umap_mek_prediction <- predict(umap_dmso_100, data = hdf5_mek_filter_inf)
# umap_dmso_prediction <- predict(umap_dmso_100, data = hdf5_dmso_filter_inf)

uwot_mek <- umap_transform(hdf5_mek_filter_inf, uwot_dmso_100, verbose = TRUE)

saveRDS(uwot_mek, here("uwot_mek.Rds"))
```


I plot the new data on the established embedding 

```{r}
umap_mek_100_meta <- hdf5_mek %>% 
  unnest(features) %>% 
  select(-contains("V")) %>% 
  semi_join(hdf5_mek, .) %>% 
  dplyr::select(metadata) %>% unnest(metadata) %>%
  mutate(morphological_class = case_when(Line %in% c("D046T01",
                                                     "D054T01",
                                                     "D055T01") ~ "disorganized",
                                         Line %in% c("D018T01") ~ "organized",
                                         Line %in% c("D027T01",
                                                     "D013T01",
                                                     "D030T01") ~ "weakly organized",
                                         Line %in% c("D010T01",
                                                     "D007T01") ~ "weakly disorganized",
                                         Line %in% c("D004T01",
                                                     "D019T01",
                                                     "D020T01",
                                                     "D022T01") ~ "intermediate",
                                         Line %in% c("D018T01") ~ "organized",
                                         TRUE ~ "other") %>% factor(levels = c("organized", "weakly organized",
                                                                               "intermediate", "weakly disorganized",
                                                                               "disorganized", "other")))

# I create a small function that centers the majority of the datapoints in the top-right corner of the embedding.
uwot_mek_oriented <- uwot_mek %>%
  as.data.frame() %>%
  janitor::clean_names() %>%
  cbind(umap_mek_100_meta) %>% as_tibble()

uwot_mek_oriented <- uwot_mek_oriented %>% 
  rowwise() %>%
  mutate(v1 = if_else(v1_center < 0, v1*(-1), v1),
         v2 = if_else(v2_center < 0, v2*(-1), v2))


uwot_mek_oriented %>% 
  ggplot(aes(v1, v2, color = Drug)) + 
  geom_point(alpha = 0.3) + 
  facet_grid(morphological_class ~ Drug) +
  theme_bw() +
  labs(x = "UMAP 1",
       y = "UMAP 2")
```

I want to annotate the MEK inhibitor data using the clustering I have generated before. In order to achieve this I use a branch of the original dbscan package in dev mode. 

```{r, eval = FALSE}
devtools::dev_mode(on = TRUE)
devtools::install_github("moredatapls/dbscan", ref = "add-hdbscan-predict")
predict(uwot_dmso_100_cluster_10, uwot_mek)

devtools::dev_mode(on = FALSE)
```

Currenlty, the prediction method does not work. Instead, for now, I simply use the x and y coordiantes of the window of interest from the DMSO embedding. 

```{r}
gg_shift <- uwot_mek_oriented %>% 
  filter(v1 < roi_dims$v1_max,
         v1 > roi_dims$v1_min,
         v2 < roi_dims$v2_max,
         v2 > roi_dims$v2_min) %>%
  mutate(Drug = if_else(Drug == "DMSO", "DMSO", "MEKi")) %>%
  filter(Line %in% c("D055T01", "D027T01")) %>% #"D018T01"
  mutate(Line_Drug = paste0(Line, " ", Drug)) %>%
  ggplot(aes(v1, v2, color = Line_Drug)) + 
  geom_point(data = uwot_dmso_100_oriented %>% filter(v1 < roi_dims$v1_max,
         v1 > roi_dims$v1_min,
         v2 < roi_dims$v2_max,
         v2 > roi_dims$v2_min) %>% dplyr::select(-morphological_class), alpha = 1, size = 0.7, color = "#f1f1f1") + 
  geom_point(alpha = 1, size = 0.7) + 
  #facet_grid(morphological_class ~ Drug) +
  #facet_wrap(~ morphological_class) +
  theme_classic() +
  labs(x = "UMAP 1",
       y = "UMAP 2") + 
  scale_color_brewer(palette = "Paired") + 
  theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) +
  guides(colour = guide_legend(nrow = 2))
  #geom_density_2d() 
  
gg_shift +
  ggsave("umap_mek.pdf", width = 12/2, height = 12/4)
```

I plot the milestones on the embedding. 

```{r}
gg_path <- uwot_dmso_100_oriented %>%
  cbind(cluster = uwot_dmso_100_cluster_10$cluster) %>%
  filter(cluster != 0) %>%
  filter(cluster %in% c(cluster_oi)) %>%
  ggplot(aes(v1, v2)) + 
  geom_point(alpha = 1, size = 0.7, color = "#f1f1f1") + 
  geom_segment(data = milestone_network_ggplot, aes(x = v1, y = v2, xend = v1_to, yend = v2_to), size = 0.7, color = "black") +
  geom_point(data = milestone_location %>% 
               mutate(x = substr(milestone, 2,2) %>% as.numeric()) %>%
               mutate(x = factor(x, levels = c(7,3,1,5,4,8,2,6))), alpha = 1, size = 1.3, aes(color = x)) + 
  
    #geom_density2d(color = "black") + 
  theme_classic() +
  labs(x = "UMAP 1",
       y = "UMAP 2")+
       #caption = "control treated organoids") + 
  #theme(legend.position = "bottom") +
  theme(legend.position = "None") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) +
  scale_x_continuous(breaks = c(-2, 0, 2)) + 
  scale_color_brewer(palette = "Spectral")

gg_path + ggsave("path.pdf")
```

This is the order of points in the embedding 

```{r}
uwot_dmso_100_oriented %>%
  cbind(cluster = uwot_dmso_100_cluster_10$cluster) %>%
  filter(cluster != 0) %>%
  filter(cluster %in% c(cluster_oi)) %>%
  ggplot(aes(v1, v2)) + 
  geom_point(alpha = 1, size = 0.7, color = "#f1f1f1") + 
  geom_point(data = milestone_location, alpha = .5, size = 1.3, color = "black") + 
  geom_segment(data = milestone_network_ggplot, aes(x = v1, y = v2, xend = v1_to, yend = v2_to), size = 1.3, color = "black") +
    #geom_density2d(color = "black") + 
  theme_classic() +
  labs(x = "UMAP 1",
       y = "UMAP 2")+
       #caption = "control treated organoids") + 
  theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) +
  scale_x_continuous(breaks = c(-2, 0, 2))+ 
  geom_label(data = milestone_location, alpha = .5, color = "black", aes(label = milestone))
```


I want to visualize the drug induced shift in a more compelling way using the pseudotime I generated. 

```{r}
milestone_prediction <- predict(clust, uwot_mek_oriented %>% dplyr::select(v1,v2)) %>% .$classification %>% 
  as.data.frame() %>% 
  cbind(uwot_mek_oriented) %>% 
  janitor::clean_names() %>% 
  rbind(predict(clust, uwot_dmso_100_oriented %>% dplyr::select(v1,v2)) %>% .$classification %>% 
  as.data.frame() %>% 
  cbind(uwot_dmso_100_oriented) %>% 
  janitor::clean_names())

milestone_prediction_length <- milestone_prediction %>% 
  mutate(Drug = if_else(drug == "DMSO", "DMSO", "MEKi")) %>% 
  mutate(distance = case_when(x ==6 ~ 0,
                              x ==2 ~ milestone_network$length[3],
                              x ==8 ~ sum(milestone_network$length[c(3,4)]),
                              x ==4 ~ sum(milestone_network$length[c(3,4,7)]),
                              x ==5 ~ sum(milestone_network$length[c(3,4,7, 6)])#, #projecting 5 onto branching point 4
                              # x ==1 ~ sum(milestone_network$length[c(3,4,7,2)]),
                              # x ==3 ~ sum(milestone_network$length[c(3,4,7,2,1)]),
                              # x ==7 ~ sum(milestone_network$length[c(3,4,7,2,1,5)])
                              )) %>% drop_na()
  
# the order of milestones
#c(7,3,1,4,8,2,6)

order <- milestone_prediction_length %>% 
  filter(Drug == "DMSO") %>% 
  group_by(line) %>% 
  summarise(distance = mean(distance)) %>% 
  arrange(desc(distance)) %>% 
  .$line


```

I generate barcharts with the organoid composition 

```{r}
gg_proportion <- milestone_prediction %>% 
  mutate(line = factor(line, levels = order)) %>%
  mutate(Drug = if_else(drug == "DMSO", "DMSO", "MEKi")) %>% 
  filter(!(line %in% c("D054T01", "D021T01", "D020T01", "D010T01"))) %>%
  filter(Drug == "DMSO") %>%
  mutate(x = factor(x, levels = c(7,3,1,5,4,8,2,6))) %>%
  ggplot(aes(line, fill = x)) + 
  geom_bar(position = "fill") + 
  theme_classic() + 
  coord_flip() + 
  #theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) + 
  scale_fill_brewer(palette = "Spectral") + 
  #facet_wrap(~ Drug)
  theme(legend.text = element_blank()) + 
  theme(legend.position = "None")
  
```



```{r}
library(ggridges)
gg_ridge <- milestone_prediction_length %>% 
  filter(!(line %in% c("D054T01", "D021T01", "D020T01", "D010T01"))) %>%
  mutate(Line_Drug = paste0(line, " ", Drug)) %>%
  mutate(line = factor(line, levels = order)) %>%
  ggplot(aes(x = distance, y = line, fill = Drug)) + 
  geom_density_ridges(rel_min_height = 0.01)+ 
  scale_fill_manual(values = c("#D55E0050", "#0072B250"), labels = c("DMSO", "MEKi")) +
  theme_ridges(center = TRUE) + 
  theme(legend.position = "bottom") + 
  theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8))

```


```{r}
uwot_mek %>%
  as.data.frame() %>%
  janitor::clean_names() %>%
  cbind(umap_mek_100_meta) %>% 
  filter(v1 < roi_dims$v1_max,
         v1 > roi_dims$v1_min,
         v2 < roi_dims$v2_max,
         v2 > roi_dims$v2_min) %>%
  mutate(Drug = if_else(Drug == "DMSO", "DMSO", "MEKi")) %>%
  filter(morphological_class %in% c("organized", "disorganized")) %>% 
  filter(v2 > 0) %>%
  ggplot(aes(v2, fill = Drug)) + 
  geom_density(alpha = 0.2) + 
  #geom_histogram(alpha = 0.2) +
  facet_wrap(~ morphological_class) +
  theme_bw() +
  labs(x = "UMAP 2") +
  scale_fill_brewer(type = "qual") +
  #geom_density_2d() +
  ggsave("umap_mek_hist.pdf", width = 12/2, height = 12/4)
```


```{r}
uwot_mek %>%
  as.data.frame() %>%
  janitor::clean_names() %>%
  cbind(umap_mek_100_meta) %>% 
  filter(v1 < roi_dims$v1_max,
         v1 > roi_dims$v1_min,
         v2 < roi_dims$v2_max,
         v2 > roi_dims$v2_min) %>%
  mutate(Drug = if_else(Drug == "DMSO", "DMSO", "MEKi")) %>%
  filter(morphological_class %in% c("organized", "disorganized")) %>% 
  filter(v2 > 0) %>% 
  lm(v1 ~ Drug + morphological_class, data = .) %>% 
  summary()
```




```{r}
library(cowplot)

plot_grid(gg_size, gg_line, 
          gg_path, gg_proportion,
          gg_shift, gg_ridge, 
          align = "h", axis = "bt", labels = "AUTO", ncol = 2) + 
  
  ggsave("embedding_plots.pdf", width = 6, height = 12)
```

# Comprehensive embedding


Now I generate the DMSO based embedding for all drugs in the dataset. To reduce my memory footprint, I run the prediction of the dataset in parallel and only keep the XY coordinate data. 

```{r, eval = FALSE}
h5closeAll()
# I identify DMSO treated wells
hdf5_all_uwot <- hdf5_path_df %>% 
  filter(exist == TRUE) %>%
  mutate(metadata = furrr::future_map(hdf5_path, ~ h5read(.x, "metadata_organoids") %>% 
                                 t() %>% 
                                 as_tibble() %>% 
                                 magrittr::set_colnames(h5read(poi, "metadata_names_organoids")) %>% 
                                 mutate(index = 1:nrow(.)) %>% 
                                 group_by(Drug) %>% 
                                 sample_frac(1))) %>%
  mutate(uwot = map2(hdf5_path, metadata, ~ {h5read(.x, "features_organoids", index=list(.y$index, c(1:1571))) %>% 
      as_tibble() %>%
      #directly run prediction
      select(contains("V")) %>%
      #magrittr::set_colnames(feature_names) %>% 
      dplyr::select(keep_features) %>%
      dplyr::select(-inf_features) %>%
      umap_transform(., uwot_dmso_100, verbose = TRUE) %>%
      as.matrix() %>% as_tibble() %>% janitor::clean_names()
      }))

h5closeAll()

saveRDS(hdf5_all_uwot, here("hdf5_all_uwot.Rds")) #hdf_all is old
```

I orient the dataset using a function.

```{r}
hdf5_all_uwot <-readRDS(here("hdf5_all_uwot.Rds")) #hdf_all is old

# I create a small function that centers the majority of the datapoints in the top-right corner of the embedding.
hdf5_all_uwot_oriented <- hdf5_all_uwot %>%
  unnest(uwot) %>% 
  dplyr::select(bc, v1, v2) %>%
  group_by(bc) %>%
  mutate(v1_center = median(v1),
         v2_center = median(v2)) %>%
  mutate(v1 = if_else(v1_center < 0, v1*(-1), v1),
         v2 = if_else(v2_center < 0, v2*(-1), v2)) %>% 
  ungroup() %>% 
  dplyr::select(-v1_center, -v2_center, -bc) %>% 
  cbind(hdf5_all_uwot %>% unnest(metadata)) %>% as_tibble()
```

### Plot all data as overview

I plot the new data on the established embedding 

```{r, eval = FALSE}
# I create a small function that centers the majority of the datapoints in the top-right corner of the embedding.
hdf5_all_uwot_oriented %>% 
  mutate(Drug = if_else(Drug == "DMSO", "DMSO", "other")) %>%
  ggplot(aes(v1, v2, color = Drug)) + 
  ggrastr::geom_point_rast(alpha = 0.1) + 
  facet_grid(Drug ~ Line) +
  theme_bw() +
  labs(x = "UMAP 1",
       y = "UMAP 2") + 
  ggsave("overview_all.pdf")
```

I check out the metadata for an individual replicate

```{r}
hdf5_all_uwot_oriented %>% 
  filter(Drug != "DMSO") %>%
  mutate(Drug = factor(Drug) %>% fct_infreq()) %>%
  ggplot(aes(Drug)) + 
  geom_bar() + 
  #scale_y_log10() + 
  theme_classic() 
```

## Identify dead orgaoinds in the comprehensive embedding. 

To further understand the latent space I am visualizing, I look for 100% lethal treatments and where objects in these treatments are in the UMAP embedding. For this purpose, I work with the highest dose of SN-38 and Bortezomib and highlight these treatments.



```{r}
set.seed(123)

viability_df <- hdf5_all_uwot_oriented %>% 
  filter(Drug %in% c("Bortezomib", "DMSO", "Irinotecan / SN-38")) %>% 
  group_by(Drug) %>% 
  filter(Concentration %in% c("nan", "1", "1.0")) %>%
  filter(v1 < roi_dims$v1_max,
         v1 > roi_dims$v1_min,
         v2 < roi_dims$v2_max,
         v2 > roi_dims$v2_min) %>%
  sample_n(3000)

gg_viability <- viability_df %>%
  ggplot(aes(v1, v2)) + 
  #geom_point(alpha  = 0.3, size = 0.7) + 
  #scale_color_brewer(type = "seq", palette = 1) + 
  facet_wrap(~ Drug, nrow = 1) + 
  scale_fill_viridis_c() +
  geom_hex(bins = 100) +
  theme_bw() + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
    labs(x = "UMAP 1",
       y = "UMAP 2")+
       #caption = "control treated organoids") + 
  theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) +
  scale_x_continuous(breaks = c(-2, 0, 2))
  
gg_viability + 
  ggsave("viability.pdf", width = 6, height = 2.5)
```

The major dynamic seems to happen in cluster one again. I apply the same filter. 

It is very dramatic to see the shift towards the lower end of the embedding containins small objects. 

I introduce a black scheme

```{r, eval + F}
library(gridExtra)
 
theme_black = function(base_size = 12, base_family = "") {
 
  theme_grey(base_size = base_size, base_family = base_family) %+replace%
 
    theme(
      # Specify axis options
      axis.line = element_blank(),  
      axis.text.x = element_text(size = base_size*0.8, color = "white", lineheight = 0.9),  
      axis.text.y = element_text(size = base_size*0.8, color = "white", lineheight = 0.9),  
      axis.ticks = element_line(color = "white", size  =  0.2),  
      axis.title.x = element_text(size = base_size, color = "white", margin = margin(0, 10, 0, 0)),  
      axis.title.y = element_text(size = base_size, color = "white", angle = 90, margin = margin(0, 10, 0, 0)),  
      axis.ticks.length = unit(0.3, "lines"),   
      # Specify legend options
      legend.background = element_rect(color = NA, fill = "black"),  
      legend.key = element_rect(color = "white",  fill = "black"),  
      legend.key.size = unit(1.2, "lines"),  
      legend.key.height = NULL,  
      legend.key.width = NULL,      
      legend.text = element_text(size = base_size*0.8, color = "white"),  
      legend.title = element_text(size = base_size*0.8, face = "bold", hjust = 0, color = "white"),  
      legend.position = "right",  
      legend.text.align = NULL,  
      legend.title.align = NULL,  
      legend.direction = "vertical",  
      legend.box = NULL, 
      # Specify panel options
      panel.background = element_rect(fill = "black", color  =  NA),  
      panel.border = element_rect(fill = NA, color = "white"),  
      panel.grid.major = element_line(color = "grey35"),  
      panel.grid.minor = element_line(color = "grey20"),  
      panel.margin = unit(0.5, "lines"),   
      # Specify facetting options
      strip.background = element_rect(fill = "grey30", color = "grey10"),  
      strip.text.x = element_text(size = base_size*0.8, color = "white"),  
      strip.text.y = element_text(size = base_size*0.8, color = "white",angle = -90),  
      # Specify plot options
      plot.background = element_rect(color = "black", fill = "black"),  
      plot.title = element_text(size = base_size*1.2, color = "white"),  
      plot.margin = unit(rep(1, 4), "lines")
 
    )
 
}
```


```{r}
gg_drugs <- hdf5_all_uwot_oriented %>% 
  filter(Drug %in% c("Cobimetinib (GDC-0973, RG7420)", "LGK974",
                     "Docetaxel", "CHIR-98014", "Bortezomib")) %>% 
  
  ggplot(aes(v1, v2)) + 
  theme_black() +
  #geom_point(alpha  = 0.3, size = 0.7) + 
  scale_fill_viridis_c() +
  geom_hex(bins = 125) +
  #scale_color_brewer(type = "seq", palette = 1) + 
  facet_wrap(~ Drug, nrow = 1) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
  
gg_drugs + 
  ggsave("gg_drugs_2d.pdf", width = 10, height = 2)
```


```{r, eval = FALSE}
gg_all <- hdf5_all_uwot_oriented %>% 
  ggplot(aes(v1, v2)) + 
  ggrastr::geom_point_rast(alpha  = 0.3, size = 0.7) + 
  #scale_color_brewer(type = "seq", palette = 1) + 
  theme_bw()

gg_all + 
  ggsave("gg_all.pdf", width = 10, height = 10)
```


```{r, eval = FALSE}
gg_all_2d <-hdf5_all_uwot_oriented %>% 
  ggplot(aes(v1, v2)) + 
  theme_classic() +
  #geom_point(alpha  = 0.3, size = 0.7) + 
  scale_fill_viridis_c() +
  geom_hex(bins = 125) +
  #scale_color_brewer(type = "seq", palette = 1) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

gg_all_2d + 
  ggsave("gg_all_2d.pdf", width = 10, height = 10)
```


```{r}
gg_all_2d_dmso <-hdf5_all_uwot_oriented %>% 
  filter(Drug == "DMSO") %>%
  ggplot(aes(v1, v2)) + 
  theme_black() +
  #geom_point(alpha  = 0.3, size = 0.7) + 
  scale_fill_viridis_c() +
  geom_hex(bins = 125) +
  #scale_color_brewer(type = "seq", palette = 1) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

gg_all_2d_dmso + 
  ggsave("gg_all_2d_dmso.pdf", width = 10, height = 10)
```

# Explore comprehensive UMAP embedding 

I want to generate example images of organoids within high density regions of the 2D embedding. For this purpose, I create a quick clustering.

```{r}
library(dbscan)
set.seed(123)

hdf5_all_uwot_oriented_sample <- hdf5_all_uwot_oriented %>% 
  #filter(Drug == "DMSO") %>%
  sample_n(10000) 

uwot_all_cluster_10 <- hdf5_all_uwot_oriented_sample %>% 
  dplyr::select(v1, v2) %>% 
  hdbscan(., minPts = 10)

saveRDS(uwot_all_cluster_10, here("uwot_dmso_100_cluster_10.Rds"))
```

Now I identify the path for objects I am interested in. 

```{r}
hdf5_all_uwot_oriented_sample %>% cbind(cluster = uwot_all_cluster_10$cluster) %>% 
  #mutate(cluster = cluster != 0) %>%
  mutate(cluster = cluster == 1) %>%
  ggplot(aes(v1,v2, color = cluster)) +
  geom_point(alpha = 0.5, size = 0.7) + 
  #geom_point_rast(alpha = 0.5, size = 0.7) +
  theme_classic() +
  labs(x = "UMAP 1",
       y = "UMAP 2") + 
  theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8)) + 
  scale_color_brewer(type = "qual")
```

Now I want to identify the image path for each most representative organoid. 

First I create an interactive example using a single image and EBImage. 

```{r}
EBImage::readImage("/home/rindtorf/data/rauscher/promise/PROMISE/data-10x-4t-c-16z/htmldir/D004T01P003L02/D004T01P003L02_B_13_1.jpeg") %>% EBImage::display()
EBImage::readImage("/home/rindtorf/data/rauscher/promise/PROMISE/data-10x-4t-c-16z/segmentationhtmldir/D004T01P003L02/D004T01P003L02_B_13_1.jpeg") %>% EBImage::display()

hdf5_all_uwot_oriented %>% filter(bc == "D004T01P003L02" & Well == "B13") %>% 
  mutate(OriginalX = as.numeric(OriginalX),
         OriginalY = as.numeric(OriginalY)) %>%
  # I scale the information to the image's size and add 50% of the y-dim to target the first field
  mutate(ScaleX = round((OriginalX/2035.5)*(514/2)),
         ScaleY = round((OriginalY/2035.5)*(514/2))) %>%
  mutate(ScaleX = case_when(Field %in% c("1", "4") ~ ScaleX,
                            Field %in% c("2", "3") ~ ScaleX + (514/2)),
         ScaleY = case_when(Field %in% c("1", "2") ~ ScaleY,
                            Field %in% c("3", "4") ~ ScaleY + (514/2))) %>%
  mutate(lowerX = ScaleX - sqrt(as.numeric(Size)),
         upperX = ScaleX + sqrt(as.numeric(Size)), 
         lowerY = ScaleY - sqrt(as.numeric(Size)), 
         upperY = ScaleY + sqrt(as.numeric(Size)))

```

It turns out that multiple clusters are private, line-specfic. 

```{r}
library(igraph)
library(ggraph)

df <- hdf5_all_uwot_oriented_sample %>% cbind(cluster = uwot_all_cluster_10$cluster) %>% filter(cluster != 0) %>% ungroup() %>% dplyr::select(from = Line, to = cluster) %>% group_by(from, to) %>% count() %>% ungroup() %>% mutate(to = paste0("cluster ", as.character(to))) 

g <- df %>% 
  graph_from_data_frame(directed = FALSE)

V(g)$type <- c(rep(FALSE, times = df$from %>% unique() %>% length),
               rep(TRUE, times = df$to %>% unique() %>% length))

plot(g, layout = layout_as_bipartite,
     vertex.color=c("green","cyan")[V(g)$type+1])

# Two columns
l <- layout.bipartite(g)
plot(g, layout = l[, c(2,1)],
     vertex.color=c("green","cyan")[V(g)$type+1])

```

Alternatilvey, I show the dataset as a heatmap. I log scaled the number of contributing organoids

```{r}
df %>% 
  mutate(n = log(n)) %>%
  spread(to, n, fill = 0) %>% 
  as.data.frame() %>% 
  column_to_rownames("from") %>% 
  pheatmap::pheatmap()
```


I also create a binary version. 

```{r}
df %>% 
  mutate(n = 1) %>%
  spread(to, n, fill = 0) %>% 
  as.data.frame() %>% 
  column_to_rownames("from") %>% 
  pheatmap::pheatmap(color = c("white", "black"),
                     clustering_distance_rows = "manhattan",
                     clustering_distance_cols = "manhattan",
                     cluster_cols = TRUE)
```

```{r}
cluster_n <- hdf5_all_uwot_oriented_sample %>% cbind(cluster = uwot_all_cluster_10$cluster) %>% filter(cluster != 0) %>% ungroup() %>% 
  group_by(Line, cluster) %>% 
  summarize(n = Replicate %>% unique() %>% length()) %>% 
  arrange(cluster) %>% 
  group_by(cluster) %>% 
  summarise(observations = sum(n)) %>% 
  arrange(observations)

cluster_n %>% 
  arrange(desc(observations)) %>%
  mutate(cluster = factor(cluster) %>% fct_inorder()) %>%
  ggplot(aes(cluster, observations)) + 
  geom_bar(stat = "identity") + 
  theme_classic()
  
```

There are no clusters that only existed in a single organoid line and replicate. 

```{r}
hdf5_all_uwot_oriented_sample %>% cbind(cluster = uwot_all_cluster_10$cluster) %>% filter(cluster != 0) %>% ungroup() %>% 
  count(cluster) %>% 
  left_join(cluster_n) %>%
  arrange(desc(n)) %>%
  mutate(cluster = factor(cluster) %>% fct_inorder()) %>%
  mutate(obs = observations) %>%
  #mutate(obs = factor(observations)) %>%
  ggplot(aes(cluster, n, fill = obs)) + 
  geom_bar(stat = "identity") + 
  scale_y_log10() + 
  theme_classic() + 
  scale_fill_viridis()
```



```{r}
library(imager)
html_dir = "/data/rauscher/promise/PROMISE/data-10x-4t-c-16z/htmldir/"

hdf5_all_uwot_stereotypes <- hdf5_all_uwot_oriented_sample %>% 
  cbind(cluster = uwot_all_cluster_10$cluster,
        score = uwot_all_cluster_10$membership_prob) %>%
  mutate(OriginalX = as.numeric(OriginalX),
         OriginalY = as.numeric(OriginalY)) %>%
  # I scale the information to the image's size and add 50% of the y-dim to target the first field
    mutate(ScaleX = round((OriginalX/2035.5)*(514/2)),
         ScaleY = round((OriginalY/2035.5)*(514/2))) %>%
  mutate(ScaleX = case_when(Field %in% c("1", "4") ~ ScaleX,
                            Field %in% c("2", "3") ~ ScaleX + (514/2)),
         ScaleY = case_when(Field %in% c("1", "2") ~ ScaleY,
                            Field %in% c("3", "4") ~ ScaleY + (514/2))) %>%
  mutate(lowerX = ScaleX - round(sqrt(as.numeric(Size))/4),
         upperX = ScaleX + round(sqrt(as.numeric(Size))/4), 
         lowerY = ScaleY - round(sqrt(as.numeric(Size))/4), 
         upperY = ScaleY + round(sqrt(as.numeric(Size))/4)) %>%
  filter(cluster != 0,
         lowerX > 0,
         lowerY > 0,
         upperX < 514,
         upperY < 514) %>%
  group_by(cluster) %>% 
  do(arrange(., desc(score)) %>% head(10)) %>% 
  mutate(path_to_html = paste0(html_dir, bc, "/", bc, "_", substr(Well, 1,1), "_", substr(Well, 2,3), "_1.jpeg")) 

hdf5_all_uwot_stereotypes_img <- hdf5_all_uwot_stereotypes %>% ungroup() %>%
  #mutate(img_raw = purrr::map(path_to_html, ~ imager::load.image(.x))) %>%
  # mutate(img = purrr::map(img_raw, ~ .x %>% as.data.frame(wide = "c") %>%
  #          mutate(rgb.val = rgb(c.1, c.2, c.3))))
  mutate(img_raw = purrr::pmap(list(p = path_to_html, a =lowerX, b = upperX, c = lowerY, d= upperY, e = bc, f = cluster, g = index, h = score), function(p, a,b,c,d, e,f,g, h) EBImage::readImage(p) %>% 
                                 .[c(a:b), c(c:d),] %>%
                                 EBImage::writeImage(., files = here(paste0("data/cluster_tiles/", f, "_", e, "_", g, "_", round(h, 2), ".jpeg")))))
  

lapply(hdf5_all_uwot_stereotypes_img$img_raw, EBImage::display, method = "raster")
```


```{r, eval = FALSE}
img_df_plot <- hdf5_all_uwot_stereotypes_img %>%
  unnest(img)

img_df_plot %>%
  # filter(x %in% lowerX:upperX,
  #        y %in% lowerY:upperY) %>%
  mutate(rgb.val = if_else(ScaleX == x | ScaleY == y, "#ffffff", rgb.val)) %>%
  ggplot(aes(x,y)) +
  geom_raster(aes(fill = rgb.val)) +
  scale_fill_identity() +
  # needs work for reversal of axes
  scale_y_reverse() +
  facet_wrap( ~ cluster + Drug + bc) +
  theme_bw() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank()) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) +
  ggsave("cluster_small.pdf", width = 40, height = 40)
```


# Cluster comprehensive embedding

Given the new insight into the structure of the data, I want to use an algorithm that bridges psuedotime inference and clustering.

* TSCAN - reasonable documentation, flexible code resource
* Mpath - R, bad documentation
* Wolf et al.PAGA - Python, fast, interpretable, no forced tree

For the sake of simplicity, I will start out with a classic graph-based clustering method first. 

```{r}
library(phenoGraph)
set.seed(123)
#I perform graph-based Louvain clustering of my huge dataset. 
cluster_data <- hdf5_all_uwot_oriented  %>% sample_n(10000)
cluster <- phenoClust(t(cluster_data %>% dplyr::select(v1, v2)))
```


I plot my test dataset. 

```{r}
cluster_data$c <- cluster$C

cluster_data %>% 
  ggplot(aes(v1, v2, color = c)) + 
  geom_point() + 
  theme_classic() +
  theme(legend.position = "bottom") +
  theme(axis.title.x = element_text(color = "black", size = 8),
        axis.title.y = element_text(color = "black", size = 8),
        axis.text.y = element_text(color = "black", size = 8),
        axis.text.x = element_text(color = "black", size = 8),
        legend.text = element_text(color = "black", size = 8),
        legend.title = element_text(color = "black", size = 8))
```

