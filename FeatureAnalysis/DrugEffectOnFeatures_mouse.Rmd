---
title: "Data Normalization and QC (Mouse)"
author: "Jan Sauer"
date: "12.10.2017"
output: 
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
---

This vignette visualizes data normalization and QC.

```{r message=FALSE, warning=FALSE, include=FALSE}
# Install and load libraries
library(PROMISE)
library(ggplot2)
library(data.table)
library(rhdf5)
library(imageHTS)
library(pander)

# Directories and files
config_dir = "/collab-ag-fischer/PROMISE/data-10x-4t-c-16z/configdir"
feature_dir = "/Users/jansauer/Thesis/Projects/PROMISE/FeatureAnalysis/features"
source(file.path(config_dir, "watchdogConfig.R"))
blurrywells = "/Users/jansauer/Thesis/Projects/PROMISE/FilterBlurryWells/mouse/blurry_wells_predicted.txt"

# Parameters
feature_type = "organoids"
hdf5_dataset = "features_tm05_zscore"
```

# Data preprocessing

The data preprocessing consists of the following steps:

* Separate objects into "organoids" (area >= 2500 pixels) and "shrapnel" (area <= 2500 pixels).
* Calculate the summary features for each of these categories of objects within a well (median / mad).
  * I decided for this summary statistic as some features may only have features within a certain range, e.g. [0, 1] for the asphericity. Even under the assumption of normally distributed variation within a well, this limitation would cause the mean to skew the summary statistic towards the middle of the interval.
* Apply glog transformation
* Subtract the median of the DMSO wells from each feature on each plate to eliminate batch effects.
* Combine plates belonging to a single cell line and calculate the z-score for each feature.

This is done in an external python script. The data and all intermediate steps are stored in the corresponding hdf5 files in the PROMISE features directory.

```{r load_data}
cell_lines = unique(substr(list.files(featuresdir, pattern = "M001"), 1, 7))
features = setNames(
  object = vector(mode="list", length=length(cell_lines)), 
  nm = cell_lines)
features_metadata = setNames(
  object = vector(mode="list", length=length(cell_lines)), 
  nm = cell_lines)
for(cell_line in cell_lines) {
  cl_feature_fn = file.path(feature_dir, sprintf("%s_averaged_features_%s.h5", cell_line, feature_type))
  features[[cell_line]] = data.frame(h5read(cl_feature_fn, hdf5_dataset))
  colnames(features[[cell_line]]) = h5read(cl_feature_fn, "feature_names")
  rownames(features[[cell_line]]) = h5read(cl_feature_fn, "well_names")
  
  features_metadata[[cell_line]] = data.frame(
    "REPLICATE" = h5read(cl_feature_fn, "replicates"),
    "DRUG" = h5read(cl_feature_fn, "drugs"), 
    row.names = rownames(features[[cell_line]]))
  H5close()
}
features = do.call(rbind, features)
rownames(features) = sapply(strsplit(rownames(features), ".", fixed = TRUE), "[[", 2)
features_metadata = do.call(rbind, features_metadata)
rownames(features_metadata) = sapply(strsplit(rownames(features_metadata), ".", fixed = TRUE), "[[", 2)
```

# Quality Control
## Comparing Positive controls

The drugs Bortezomib (PS-341) is a potential positive control. To see how suitable it is for this, I look at how they compare to DMSO, the negative control. To compare treatments, I look at the number of organoids as a proxy for organoid survival.
```{r}
sf_drug = features_metadata[,"DRUG"]
sf_num_organoids = features[,"organoids_num.of.objects"]
sf_avg_org_size = features[,"organoids_x.0.s.area_expected"]
sf_total_area = features[,"Total.Biomass"]

simple_features = data.frame(
  "Num.Objects" = sf_num_organoids,
  "Avg.Org.Size" = sf_avg_org_size,
  "Total.Area" = sf_total_area,
  "Drug" = sf_drug,
  "Cell.Line" = substr(rownames(features), 1, 7)
)
```

```{r}
ggplotdf = simple_features[simple_features$Drug %in% c("DMSO", "Bortezomib (PS-341)"),]
ggplot(data = ggplotdf) + geom_boxplot(aes(x = Cell.Line, y = Num.Objects, fill = Drug)) + 
  ggtitle(label = "Number of Organoids per Well (Bortezomib (PS-341))") + xlab("Cell Line") + 
  ylab("Number of Organoids")
```

```{r}
ggplot(data = ggplotdf) + geom_boxplot(aes(x = Cell.Line, y = Avg.Org.Size, fill = Drug)) + 
  ggtitle(label = "Average Are of Organoids (Bortezomib (PS-341))") + 
  xlab("Cell Line") + ylab("Average Area")
```

```{r}
ggplot(data = ggplotdf) + geom_boxplot(aes(x = Cell.Line, y = Total.Area, fill = Drug)) + 
  ggtitle(label = "Total Biomass per Well (Bortezomib (PS-341))") + 
  xlab("Cell Line") + ylab("Total Biomass Area")
```

## Combining Positive Controls

This section is currently redundant but will make sense once more positive pseudo-controls are selected for the mouse screens.
```{r}
valid_entries = features_metadata$DRUG %in% c("DMSO", "Bortezomib (PS-341)")
features_combined = features[valid_entries,]
features_metadata_combined = features_metadata[valid_entries,]
features_metadata_combined$DRUG = ifelse(
  test = features_metadata_combined$DRUG == "DMSO",
  yes = "NEG_CTRL", no = "POS_CTRL")
```

```{r}
simple_features = data.frame(
  "Num.Objects" = features_combined[,"organoids_num.of.objects"],
  "Avg.Org.Size" = features_combined[,"organoids_x.0.s.area_expected"],
  "Total.Area" = features_combined[,"Total.Biomass"],
  "Drug" = features_metadata_combined[,"DRUG"],
  "Cell.Line" = substr(rownames(features_combined), 1, 7)
)
```

```{r}
ggplot(data = simple_features) + geom_boxplot(aes(x = Cell.Line, y = Num.Objects, fill = Drug)) +
  ggtitle(label = "Number of Organoids per Well",
          subtitle = "Grouped positive controls at concentrations of 1 and 0.2") + xlab("Cell Line") +
  ylab("Number of Organoids")
```

```{r}
ggplot(data = simple_features) + geom_boxplot(aes(x = Cell.Line, y = Avg.Org.Size, fill = Drug)) +
  ggtitle(label = "Average Area of Organoids per Well",
          subtitle = "Grouped positive controls at concentrations of 1 and 0.2") + xlab("Cell Line") +
  ylab("Average Area of of Organoids")
```

```{r}
ggplot(data = simple_features) + geom_boxplot(aes(x = Cell.Line, y = Total.Area, fill = Drug)) +
  ggtitle(label = "Total Area of Biomass per Well",
          subtitle = "Grouped positive controls at concentrations of 1 and 0.2") + xlab("Cell Line") +
  ylab("Total Area of Biomass")
```

## Cell Line Quality
The average number of organoids as well as the total biomass are features that should vary strongly between the two controls. Consequently, I will exclude any cell lines for which the two controls cannot be properly separated. For this, I determine the z-factor for both the biomass and the number of organoids:

$$ Z^\prime = 1 - \frac{3 \cdot (\sigma_p + \sigma_n)}{|\mu_p - \mu_n|}$$

```{r}
biomass_zprime = setNames(
  object = vector(mode="numeric", length=length(cell_lines)), 
  nm = cell_lines)
organoids_zprime = setNames(
  object = vector(mode="numeric", length=length(cell_lines)), 
  nm = cell_lines)
for(cell_line in cell_lines) {
  cl_simple_features = simple_features[simple_features$Cell.Line == cell_line, ]
  organoids_zprime[[cell_line]] = zprime(
    cl_simple_features[cl_simple_features$Drug == "NEG_CTRL", "Num.Objects"], 
    cl_simple_features[cl_simple_features$Drug == "POS_CTRL", "Num.Objects"], 
    method = "robust")
  biomass_zprime[[cell_line]] = zprime(
    cl_simple_features[cl_simple_features$Drug == "NEG_CTRL", "Total.Area"], 
    cl_simple_features[cl_simple_features$Drug == "POS_CTRL", "Total.Area"], 
    method = "robust")
}
ggplotdf = data.frame(
  "Cell.Line" = names(organoids_zprime), 
  "Total.Biomass" = biomass_zprime, 
  "Num.Organoids" = organoids_zprime)
ggplotdf = melt(ggplotdf, id.vars = "Cell.Line")
ggplot(data = ggplotdf) + 
  geom_col(aes(x = Cell.Line, y = value, fill = variable), 
           position = position_dodge())
```

Usually, a value of Z' $\approx$ 0.5 indicates a good assay and a value of Z <= 0 indicates a bad assay. However, the two control populations are clearly separable, as shown by the wilcoxon test (a non-parametric test for determining if two samples come from different populations) for the number of organoids and total biomass.
```{r}
wilcox_organoids_p = setNames(
  object = vector(mode="numeric", length=length(cell_lines)), 
  nm = cell_lines)
wilcox_biomass_p = setNames(
  object = vector(mode="numeric", length=length(cell_lines)), 
  nm = cell_lines)
for(cell_line in cell_lines) {
  cl_simple_features = simple_features[simple_features$Cell.Line == cell_line, ]
  wilcox_organoids_p[[cell_line]] = wilcox.test(
    cl_simple_features[cl_simple_features$Drug == "NEG_CTRL", "Num.Objects"], 
    cl_simple_features[cl_simple_features$Drug == "POS_CTRL", "Num.Objects"], 
    conf.int = TRUE)$p.value
  wilcox_biomass_p[[cell_line]] = wilcox.test(
    cl_simple_features[cl_simple_features$Drug == "NEG_CTRL", "Total.Area"], 
    cl_simple_features[cl_simple_features$Drug == "POS_CTRL", "Total.Area"], 
    conf.int = TRUE)$p.value
}

panderdf = data.frame(
  "Total.Biomass" = wilcox_biomass_p, 
  "Num.Objects" = wilcox_organoids_p)
pandoc.table(
  panderdf, emphasize.strong.cells = which(panderdf > 0.05, arr.ind = TRUE), 
  caption = "Probabilities that the feature values for the positive and negative controls come from the same distribution (p-values of Wilcoxon test)")
```

With the exception of M001W01, all cell lines show a significant separation between the positive and negative control samples with regards to the total biomass feature. A look at the z-factor for all features:
```{r}
# Calculate z factors for each cell line / feature combination
pos_ctrl = features_combined[features_metadata_combined$DRUG == "POS_CTRL",]
pos_ctrl_metadata = features_metadata_combined[features_metadata_combined$DRUG == "POS_CTRL",]
neg_ctrl = features_combined[features_metadata_combined$DRUG == "NEG_CTRL",]
neg_ctrl_metadata = features_metadata_combined[features_metadata_combined$DRUG == "NEG_CTRL",]
feature_z_factors = matrix(
  NA_real_, nrow = length(cell_lines), ncol = ncol(features_combined),
  dimnames = list(cell_lines, colnames(features_combined)))
for(feature in colnames(features_combined)) {
  for(cell_line in cell_lines) {
    feature_z_factors[cell_line, feature] = zprime(
      pos_ctrl[substr(rownames(pos_ctrl), 1, 7) == cell_line, feature],
      neg_ctrl[substr(rownames(neg_ctrl), 1, 7) == cell_line, feature],
      method = "robust")
  }
}

feature_z_factors_df = apply(feature_z_factors, 1, sort)
feature_z_factors_df = do.call(what = c, args = feature_z_factors_df)
feature_z_factors_df = data.frame(
  "Cell.Line" = sapply(strsplit(names(feature_z_factors_df), ".", fixed = TRUE), "[[", 1), 
  "ZFactor" = feature_z_factors_df)
feature_z_factors_df = feature_z_factors_df[is.finite(feature_z_factors_df$ZFactor),]
feature_z_factors_df$Features = NA_real_
for(cell_line in cell_lines) {
  feature_z_factors_df[
    feature_z_factors_df$Cell.Line == cell_line, 
    "Features"] = seq_len(table(
      feature_z_factors_df$Cell.Line)[cell_line])
}

ggplot(data = feature_z_factors_df) + geom_line(aes(x = Features, y = ZFactor, color = Cell.Line)) + 
  coord_cartesian(ylim = c(-1, 1)) + ggtitle(label = "Z-Factor for the features of each cell line")
```

## Pruning Features

Features only make sense if they are sufficiently continuous. I want to discard features that are constant across the negative (DMSO) controls of a plate. A look at the 'minimum ratio' of unique values for each feature across plates shows that features are either continuous or constant across a plate, but with a rather large transition inbetween. I keep only features with more than 75% unique values across all plates.
```{r}
neg_ctrl = features_combined[features_metadata_combined$DRUG == "NEG_CTRL", ]
# This rounding ensures that there are no floating point arithmetic errors that are mistaken as unique values
neg_ctrl = round(neg_ctrl, 8)
neg_ctrl_cl = substr(rownames(neg_ctrl), 1, 14)
unique_vals = aggregate(neg_ctrl, list(neg_ctrl_cl), function(x) length(unique(x)) / length(x))
rownames(unique_vals) = unique_vals$Group.1
unique_vals$Group.1 = NULL
unique_vals_min = apply(unique_vals, 2, min)
unique_vals_min_df = data.frame(
  "Ratio.Unique.Vals" = sort(unique_vals_min, decreasing = TRUE), 
  "Features" = seq_along(unique_vals_min))
ggplot(data = unique_vals_min_df) + geom_point(aes(x = Features, y = Ratio.Unique.Vals)) + 
  ggtitle("Minimum Ratio of Unique Values for each Feature", 
          subtitle = "e.g. a 'minimum ratio' of 0.5 means all plates had a ratio of >= 0.5 of unique values for that feature")

features = features[,names(which(unique_vals_min >= 0.75))]
features_combined = features_combined[,names(which(unique_vals_min >= 0.75))]
```

## Correlation between replicates
### Cell line specfific
I look at all features now to see how well they correlate between replicates of the screen for each cell line individually

```{r}
cl_correlations = setNames(
  object = vector(mode = "list", length = length(cell_lines)), 
  nm = cell_lines
)
for(cell_line in cell_lines) {
  cl_features = features[substr(rownames(features), 1, 7) == cell_line, ]
  cl_features_metadata = features_metadata[substr(rownames(features_metadata), 1, 7) == cell_line, ]
  rep1 = cl_features[cl_features_metadata$REPLICATE == 1, ]
  rep2 = cl_features[cl_features_metadata$REPLICATE == 2, ]
  if(!identical(paste0(substr(rownames(rep1), 1, 7), "_", substr(rownames(rep1), 12, 19)), 
                paste0(substr(rownames(rep2), 1, 7), "_", substr(rownames(rep2), 12, 19)))) {
    warning("Replicates are not in the same order!")
  }
  rep_correlations = setNames(
    object = vector(mode = "numeric", length = ncol(cl_features)), 
    nm = colnames(cl_features))
  for(feature in colnames(cl_features)) {
    rep_correlations[[feature]] = cor(
      rep1[[feature]], rep2[[feature]], 
      use = "pairwise.complete.obs")
  }
  rep_correlations = sort(rep_correlations, decreasing = TRUE)
  cl_correlations[[cell_line]] = data.frame(
    "Features" = seq_along(rep_correlations), 
    "Correlations" = rep_correlations, 
    "Cell.Line" = cell_line
  )
}

cl_correlations = do.call(rbind, cl_correlations)
ggplot(data = cl_correlations) + geom_line(aes(x = Features, y = Correlations, color = Cell.Line)) + 
  ggtitle("Correlations between Replicates for each Individual Cell Line")
```

### Screen-wide
```{r, warning=FALSE}
rep1 = features[features_metadata$REPLICATE == 1, ]
rep2 = features[features_metadata$REPLICATE == 2, ]
if(!identical(paste0(substr(rownames(rep1), 1, 7), "_", substr(rownames(rep1), 12, 19)), 
              paste0(substr(rownames(rep2), 1, 7), "_", substr(rownames(rep2), 12, 19)))) {
  warning("Replicates are not in the same order!")
}

rep_correlations = setNames(
  object = vector(mode = "numeric", length = ncol(features)), 
  nm = colnames(features))
for(feature in colnames(features)) {
  rep_correlations[[feature]] = cor(
    rep1[[feature]], rep2[[feature]], 
    use = "pairwise.complete.obs")
}

ggplotdf = data.frame(
  "Features" = seq_along(sort(rep_correlations)),
  "Correlation" = sort(rep_correlations, decreasing = TRUE))
ggplot(data = ggplotdf) + geom_line(aes(x = Features, y = Correlation)) + 
  ggtitle("Correlations between Replicates across all Cell Lines")
```

<!-- # Finding Characteristic Features -->

<!-- Relying on a single statistic for feature quality may introduce biases, such as ignoring features that may differentiate specific treatments but not the controls from each other. Instead, I directly perform a stepwise feature selection, as per Fischer et al. 2015 ("A Map of Directional Genetic Interactions in a Metazoan Cell") and Laufer et al. 2013 ("Mapping genetic interactions in human cancer cells"). Feature selection is performed on the combined feature set for all cell lines. This entails the following steps: -->
<!-- 1. Choose an initial feature set. This will be the number of organoids and the total biomass, both of which suitably separated the positive from negative controls. -->
<!-- 2. Model each replicate of the remaining features as a function of the already chosen feature set. Since I am interested in extracting features with the highest signal-to-noise ratio, the feature with the highest correlation between replicate residuals is added to the feature set. -->
<!-- 3. Repeat step 2 with the new feature set until the distribution of the correlation of all remaining residuals is centered around 0, i.e. none of the remaining features add any information. -->

<!-- To reduce the runtime of the feature selection, I begin with a preselection. I remove all features with no variation across the entire screen and then remove all features that strongly correlate with each other. -->
<!-- ```{r} -->
<!-- features_reduced = features -->

<!-- # Remove constant features -->
<!-- features_var = apply(features, 2, var) -->
<!-- features_reduced = features_reduced[, names(which(features_var > 0))] -->

<!-- # Calculate correlations -->
<!-- features_cor = cor(features_reduced, use = "pairwise.complete.obs") -->
<!-- feature_cor_vector = feature_cor[upper.tri(feature_cor, diag = FALSE)] -->
<!-- feature_cor[upper.tri(feature_cor, diag = TRUE)] = 0 -->
<!-- features_reduced <- features_reduced[,!apply(feature_cor,2,function(x) any(x > 0.90))] -->
<!-- ``` -->


<!-- To optimize the runtime of the feature selection, I begin by removing any features that strongly correlate with each other ($\rho$ >= 0.99) -->
<!-- ```{r} -->
<!-- features_stepwise = features -->
<!-- other_features = colnames(features_stepwise)[ -->
<!--   !colnames(features_stepwise) %in% c("Total.Biomass")] -->
<!-- other_feature_cors = setNames( -->
<!--   object = vector(mode = "numeric", length = length(other_features)),  -->
<!--   nm = other_features) -->
<!-- for(feature in other_features) { -->
<!--   other_feature_cors = cor() -->
<!-- } -->

<!-- ``` -->

<!-- ```{r} -->
<!-- # Choose the best three as a starting set -->
<!-- initial_set = c("organoids_num.of.objects", "total.area.of.biomass") -->
<!-- selected_features = initial_set -->
<!-- remaining_features = colnames(features_combined)[ -->
<!--   !colnames(features_combined) %in% selected_features] -->

<!-- # Remember statistics on the correlations -->
<!-- all_correlations = list() -->
<!-- ratio_positive = c() -->

<!-- # Calculate the fit for each replicate and save the residuals -->
<!-- while(length(remaining_features) > 0) { -->
<!--   residuals = array(0, dim = c(nrow(features_combined), 2, length(remaining_features))) -->
<!--   dimnames(residuals) = list(NULL, NULL, remaining_features) -->
<!--   for(feat in remaining_features) { -->
<!--     model1 = lm( -->
<!--     features_combined[features_metadata_combined$REPLICATE == 1, feat] ~ -->
<!--       as.matrix(features_combined[features_metadata_combined$REPLICATE == 1, selected_features])) -->
<!--     model2 = lm( -->
<!--       features_combined[features_metadata_combined$REPLICATE == 2, feat] ~ -->
<!--         as.matrix(features_combined[features_metadata_combined$REPLICATE == 2, selected_features])) -->
<!--     residuals[,1,feat] = model1$residuals -->
<!--     residuals[,2,feat] = model2$residuals -->
<!--   } -->

<!--   # Calculate the correlation -->
<!--   correlations = apply(residuals, 3, function(x) { -->
<!--     x1 = x[,1] -->
<!--     x2 = x[,2] -->
<!--     I = which(is.finite(x1) & is.finite(x2)) -->
<!--     cor(x1[I], x2[I]) -->
<!--   }) -->

<!--   to_select = names(correlations)[which.max(correlations)] -->
<!--   selected_features = c(selected_features, to_select) -->
<!--   remaining_features = colnames(features_combined)[ -->
<!--     !colnames(features_combined) %in% selected_features] -->
<!--   all_correlations = c(all_correlations, list(correlations)) -->
<!--   ratio_positive = c(ratio_positive, sum(correlations > 0, na.rm = TRUE) / length(correlations)) -->
<!-- } -->

<!-- # Keep only the selected features with a ratio > 0.5 of positively correlated residual matrices -->
<!-- selected_features = selected_features[c(rep(TRUE, length(initial_set)), ratio_positive > 0.5)] -->
<!-- ``` -->











<!-- Next, I am interested in finding features that allow for a similar separation between positive and negative controls. The two conditions I impose are: -->

<!-- * The features come from two distinct distributions for positive and negative controls. This is determined via the robust z-factor. -->
<!-- * The "vector" pointing from the negative to the positive controls must have the same direction for each cell line, i.e. the mean of the features for the positive controls must be unanimously greater than or less than the mean of the features for the negative controls for across all cell lines. I permit one "outlier" cell line (e.g. as is the case for D015T01 with regard to the total biomass) -->

<!-- ```{r} -->
<!-- # Begin by removing those features without a unanimous direction between positive and negative -->
<!-- # control. -->
<!-- permitted_outliers = 1 -->

<!-- pos_ctrl = features_combined[features_metadata_combined$DRUG == "POS_CTRL",] -->
<!-- pos_ctrl_metadata = features_metadata_combined[features_metadata_combined$DRUG == "POS_CTRL",] -->
<!-- pos_ctrl_mean = aggregate(pos_ctrl, list(substr(rownames(pos_ctrl), 1, 7)), mean) -->
<!-- rownames(pos_ctrl_mean) = pos_ctrl_mean$Group.1 -->
<!-- pos_ctrl_mean$Group.1 = NULL -->

<!-- neg_ctrl = features_combined[features_metadata_combined$DRUG == "NEG_CTRL",] -->
<!-- neg_ctrl_metadata = features_metadata_combined[features_metadata_combined$DRUG == "NEG_CTRL",] -->
<!-- neg_ctrl_mean = aggregate(neg_ctrl, list(substr(rownames(neg_ctrl), 1, 7)), mean) -->
<!-- rownames(neg_ctrl_mean) = neg_ctrl_mean$Group.1 -->
<!-- neg_ctrl_mean$Group.1 = NULL -->

<!-- pos_neg_dir = (pos_ctrl_mean - neg_ctrl_mean) > 0 -->
<!-- invalid_features = names(which( -->
<!--   (colSums(pos_neg_dir) > permitted_outliers) & -->
<!--   (colSums(pos_neg_dir) < (nrow(pos_neg_dir) - permitted_outliers)))) -->
<!-- features_combined[,invalid_features] = NULL -->

<!-- # Calculate z factors for each cell line / feature combination -->
<!-- pos_ctrl = features_combined[features_metadata_combined$DRUG == "POS_CTRL",] -->
<!-- pos_ctrl_metadata = features_metadata_combined[features_metadata_combined$DRUG == "POS_CTRL",] -->
<!-- neg_ctrl = features_combined[features_metadata_combined$DRUG == "NEG_CTRL",] -->
<!-- neg_ctrl_metadata = features_metadata_combined[features_metadata_combined$DRUG == "NEG_CTRL",] -->
<!-- feature_z_factors = matrix( -->
<!--   NA_real_, nrow = length(cell_lines), ncol = ncol(features_combined), -->
<!--   dimnames = list(cell_lines, colnames(features_combined))) -->
<!-- for(feature in colnames(features_combined)) { -->
<!--   for(cell_line in cell_lines) { -->
<!--     feature_z_factors[cell_line, feature] = zprime( -->
<!--       pos_ctrl[substr(rownames(pos_ctrl), 1, 7) == cell_line, feature], -->
<!--       neg_ctrl[substr(rownames(neg_ctrl), 1, 7) == cell_line, feature], -->
<!--       method = "robust") -->
<!--   } -->
<!-- } -->

<!-- # Average over cell lines; ignore NA-values -->
<!-- feature_z_factors_avg = colMeans(feature_z_factors, na.rm = TRUE) -->
<!-- feature_z_factors_avg = feature_z_factors_avg[is.finite(feature_z_factors_avg)] -->


<!-- pos_ctrl_var = aggregate(pos_ctrl, list(pos_ctrl_metadata$CELL.LINE), var) -->
<!-- rownames(pos_ctrl_var) = pos_ctrl_var$Group.1 -->
<!-- pos_ctrl_var$Group.1 = NULL -->

<!-- # Negative controls -->

<!-- neg_ctrl_var = aggregate(neg_ctrl, list(neg_ctrl_metadata$CELL.LINE), var) -->
<!-- rownames(neg_ctrl_var) = neg_ctrl_var$Group.1 -->
<!-- neg_ctrl_var$Group.1 = NULL -->

<!-- within_group_var = (pos_ctrl_var + neg_ctrl_var) / 2 -->

<!-- # Between-group variance -->
<!-- between_group_var = aggregate(features_combined, list(features_metadata_combined$CELL.LINE), var) -->
<!-- rownames(between_group_var) = between_group_var$Group.1 -->
<!-- between_group_var$Group.1 = NULL -->

<!-- # Calculate ratio and apply a trimmed mean (trim 2 cell lines off both ends) -->
<!-- var_ratio = between_group_var / within_group_var -->
<!-- var_ratio_trimmed_mean = apply(var_ratio, 2, function(x) { -->
<!--   s = sort(x) -->
<!--   s = s[3:(length(s) - 2)] -->
<!--   mean(s) -->
<!-- }) -->

<!-- qplot( -->
<!--   x = seq_along(var_ratio_trimmed_mean), y = sort(var_ratio_trimmed_mean, decreasing = TRUE), -->
<!--   xlab = "Features", ylab = "Variance Ratio", -->
<!--   main = "Between-Group Variance / Within-Group Variance") -->
<!-- ``` -->

<!-- The number of organoids, as investigated above, are a good indicator of organoid viability, so I will use the variance ratio for this feature as the lower threshold for the feature selection. Any feature with a better separability and a near-unanimous effect direction between controls can be considered a potential indicator of organoid viability. -->

<!-- ```{r} -->
<!-- lower_thresh = var_ratio_trimmed_mean["organoids_num.of.objects"] -->
<!-- possible_features = names(which(var_ratio_trimmed_mean >= lower_thresh)) -->
<!-- features_combined = features_combined[,possible_features] -->
<!-- ``` -->

<!-- As a final step, I want to make sure that the features weren't chosen simply because they correlate strongly. Therefore, I apply a stepwise feature selection, as per Fischer et al. 2015 ("A Map of Directional Genetic Interactions in a Metazoan Cell") and Laufer et al. 2013 ("Mapping genetic interactions in human cancer cells"). Feature selection is performed on the combined feature set for all cell lines. This entails the following steps: -->
<!-- 1. Choose an initial feature set. This will be the number of organoids and the total biomass, both of which suitably separated the positive from negative controls. -->
<!-- 2. Model each replicate of the remaining features as a function of the already chosen feature set. Since I am interested in extracting features with the highest signal-to-noise ratio, the feature with the highest correlation between replicate residuals is added to the feature set. -->
<!-- 3. Repeat step 2 with the new feature set until the distribution of the correlation of all remaining residuals is centered around 0, i.e. none of the remaining features add any information. -->

<!-- ```{r} -->
<!-- # Choose the best three as a starting set -->
<!-- initial_set = c("organoids_num.of.objects", "total.area.of.biomass") -->
<!-- selected_features = initial_set -->
<!-- remaining_features = colnames(features_combined)[ -->
<!--   !colnames(features_combined) %in% selected_features] -->

<!-- # Remember statistics on the correlations -->
<!-- all_correlations = list() -->
<!-- ratio_positive = c() -->

<!-- # Calculate the fit for each replicate and save the residuals -->
<!-- while(length(remaining_features) > 0) { -->
<!--   residuals = array(0, dim = c(nrow(features_combined), 2, length(remaining_features))) -->
<!--   dimnames(residuals) = list(NULL, NULL, remaining_features) -->
<!--   for(feat in remaining_features) { -->
<!--     model1 = lm( -->
<!--     features_combined[features_metadata_combined$REPLICATE == 1, feat] ~ -->
<!--       as.matrix(features_combined[features_metadata_combined$REPLICATE == 1, selected_features])) -->
<!--     model2 = lm( -->
<!--       features_combined[features_metadata_combined$REPLICATE == 2, feat] ~ -->
<!--         as.matrix(features_combined[features_metadata_combined$REPLICATE == 2, selected_features])) -->
<!--     residuals[,1,feat] = model1$residuals -->
<!--     residuals[,2,feat] = model2$residuals -->
<!--   } -->

<!--   # Calculate the correlation -->
<!--   correlations = apply(residuals, 3, function(x) { -->
<!--     x1 = x[,1] -->
<!--     x2 = x[,2] -->
<!--     I = which(is.finite(x1) & is.finite(x2)) -->
<!--     cor(x1[I], x2[I]) -->
<!--   }) -->

<!--   to_select = names(correlations)[which.max(correlations)] -->
<!--   selected_features = c(selected_features, to_select) -->
<!--   remaining_features = colnames(features_combined)[ -->
<!--     !colnames(features_combined) %in% selected_features] -->
<!--   all_correlations = c(all_correlations, list(correlations)) -->
<!--   ratio_positive = c(ratio_positive, sum(correlations > 0, na.rm = TRUE) / length(correlations)) -->
<!-- } -->

<!-- # Keep only the selected features with a ratio > 0.5 of positively correlated residual matrices -->
<!-- selected_features = selected_features[c(rep(TRUE, length(initial_set)), ratio_positive > 0.5)] -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ratio_color = ifelse(ratio_positive >= 0.5, "1", "2") -->
<!-- ggplot(data = data.frame( -->
<!--   "Iteration" = seq_along(ratio_positive), -->
<!--   "Ratio" = ratio_positive-0.5)) + -->
<!--   geom_bar(aes(x = Iteration, y = Ratio, fill = ratio_color), stat = "identity") + -->
<!--   ggtitle("Ratio of features with positive correlation after each iteration") + -->
<!--   theme(legend.position = "none") + scale_y_continuous(labels = function(x) x+0.5) -->
<!-- ``` -->

<!-- What remains are \Sexpr(length(selected_features)) features used to describe organoid viability -->

<!-- ```{r} -->
<!-- print(selected_features) -->
<!-- features_combined = features_combined[,selected_features] -->
<!-- ``` -->

<!-- A few examples for these features are shown below -->
<!-- ```{r} -->
<!-- feature_of_interest = colnames(features_combined)[3] -->
<!-- simple_features = data.frame( -->
<!--   "Num.Objects" = features_combined[, feature_of_interest], -->
<!--   "Num.Objects.Noise" = features_combined[, feature_of_interest], -->
<!--   "Drug" = features_metadata_combined[, "DRUG"], -->
<!--   "Cell.Line" = substr(rownames(features_combined), 1, 7) -->
<!-- ) -->
<!-- ggplot(data = simple_features) + geom_boxplot(aes(x = Cell.Line, y = Num.Objects, fill = Drug)) + -->
<!--   ggtitle(label = sprintf("Feature '%s'", feature_of_interest)) + -->
<!--   xlab("Cell Line") + ylab("Number of Organoids") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- feature_of_interest = colnames(features_combined)[6] -->
<!-- simple_features = data.frame( -->
<!--   "Num.Objects" = features_combined[, feature_of_interest], -->
<!--   "Num.Objects.Noise" = features_combined[, feature_of_interest], -->
<!--   "Drug" = features_metadata_combined[, "DRUG"], -->
<!--   "Cell.Line" = substr(rownames(features_combined), 1, 7) -->
<!-- ) -->
<!-- ggplot(data = simple_features) + geom_boxplot(aes(x = Cell.Line, y = Num.Objects, fill = Drug)) + -->
<!--   ggtitle(label = sprintf("Feature '%s'", feature_of_interest)) + -->
<!--   xlab("Cell Line") + ylab("Number of Organoids") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- feature_of_interest = colnames(features_combined)[20] -->
<!-- simple_features = data.frame( -->
<!--   "Num.Objects" = features_combined[, feature_of_interest], -->
<!--   "Num.Objects.Noise" = features_combined[, feature_of_interest], -->
<!--   "Drug" = features_metadata_combined[, "DRUG"], -->
<!--   "Cell.Line" = substr(rownames(features_combined), 1, 7) -->
<!-- ) -->
<!-- ggplot(data = simple_features) + geom_boxplot(aes(x = Cell.Line, y = Num.Objects, fill = Drug)) + -->
<!--   ggtitle(label = sprintf("Feature '%s'", feature_of_interest)) + -->
<!--   xlab("Cell Line") + ylab("Number of Organoids") -->
<!-- ``` -->

<!-- # Next Chapter -->

<!-- Hello -->