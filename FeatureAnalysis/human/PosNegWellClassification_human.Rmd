---
title: "Live vs. Dead Organoid Classification (Human)"
author: "Jan Sauer"
date: "22.10.2017"
output: 
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
---

This vignette performs a feature selection and trains a classifier to differentiate live from dead organoids. It uses the selected features from the Quality Control vignette. I use the same positive controls defined in the quality control step:
* Staurosporine_500nM
* Bortezomib @ concentration 0.2 and 1.0
* Irinotecan / SN-38 @ concentration 0.2 and 1.0
* Volasertib @ concentration 0.2 and 1.0
* Methotrexate @ concentration 0.2 and 1.0

```{r, message=FALSE}
library(randomForest)
library(PROMISE)
config_dir = "/collab-ag-fischer/PROMISE/data-10x-4t-c-16z/configdir"
source(file.path(config_dir, "watchdogConfig.R"))

setwd("/Users/jansauer/Thesis/Projects/PROMISE/FeatureAnalysis/human/")
features = readRDS("QC_human__stability_selection__features.rds")
features_metadata = readRDS("QC_human__stability_selection__features_metadata.rds")
```

# Well classification

## Strict Positive Controls

To test the features, a simple classifier is trained to differentiate positive from negative wells. Random forests are among the best performing supervised classifiers.

```{r}
pos_controls = c("Bortezomib", "Irinotecan / SN-38")
valid_entries = features_metadata$DRUG %in% pos_controls & 
  features_metadata$CONCENTRATION %in% c(0.2, 1)

features_pos = features[valid_entries, ]
features_neg = features[features_metadata$DRUG == "DMSO", ]

# Balance training samples
nsamples = min(nrow(features_pos), nrow(features_neg))
features_neg = features_neg[sample(seq_len(nrow(features_neg)), nsamples, replace = FALSE), ]
features_neg$TYPE = "NEG_CTRL"
features_pos = features_pos[sample(seq_len(nrow(features_pos)), nsamples, replace = FALSE), ]
features_pos$TYPE = "POS_CTRL"

# Combine into one dataframe
features_rf = rbind.data.frame(features_neg, features_pos)
features_rf$TYPE = as.factor(features_rf$TYPE)

# Split into training and testing data
test_indices = sample(seq_len(nrow(features_rf)), nrow(features_rf) * 0.25, replace = FALSE)
rf_train = features_rf[-test_indices, ]
rf_test = features_rf[test_indices, ]

# Run training and evaluation
rfmodel = randomForest(TYPE ~ ., data = rf_train)
ypredict = predict(object = rfmodel, rf_test)
print(table(ypredict, rf_test$TYPE))
```

The features are apparently exceptionally good at differentiating positive from negative control wells.

The actual positive controls, Staurosporine, were excluded from this training because not all cell lines reacted as expected to them. This was most likely an issue with the concentration used. Apply the above classifier to these wells shows that many of them are incorrectly classified as negative controls. This, curiously, only applies to some cell lines, however.
```{r}
features_stauro = features[features_metadata$DRUG == "Staurosporine_500nM", ]
stauro_prediction = predict(object = rfmodel, features_stauro)
print(table(stauro_prediction, substr(names(stauro_prediction), 1, 4)))
```

A look at some of the Staurosporine wells:
```{r}
incorrectly_predicted_wells = names(
  stauro_prediction)[which(stauro_prediction == "NEG_CTRL")[c(1, 50, 70, 100)]]
correctly_predicted_wells = names(
  stauro_prediction)[which(stauro_prediction == "POS_CTRL")[c(1, 50, 70, 100)]]
incorrectly_predicted_wells = strsplit(incorrectly_predicted_wells, "_")
correctly_predicted_wells = strsplit(correctly_predicted_wells, "_")
preview_fns_pos = sapply(correctly_predicted_wells, function(x) {
  thumbnailFilename(
  filedir = file.path(htmldir, x[1]), 
  platename = x[1], row = x[2], col = x[3])
})
preview_fns_neg = sapply(incorrectly_predicted_wells, function(x) {
  thumbnailFilename(
  filedir = file.path(htmldir, x[1]), 
  platename = x[1], row = x[2], col = x[3])
})
```
![`r correctly_predicted_wells[[1]]`; Identified as positive control](`r preview_fns_pos[[1]]`)

![`r correctly_predicted_wells[[2]]`; Identified as positive control](`r preview_fns_pos[[2]]`)

![`r correctly_predicted_wells[[3]]`; Identified as positive control](`r preview_fns_pos[[3]]`)

![`r correctly_predicted_wells[[4]]`; Identified as positive control](`r preview_fns_pos[[4]]`)

![`r incorrectly_predicted_wells[[1]]`; Identified as negative control](`r preview_fns_neg[[1]]`)

![`r incorrectly_predicted_wells[[2]]`; Identified as negative control](`r preview_fns_neg[[2]]`)

![`r incorrectly_predicted_wells[[3]]`; Identified as negative control](`r preview_fns_neg[[3]]`)

![`r incorrectly_predicted_wells[[4]]`; Identified as negative control](`r preview_fns_neg[[4]]`)

## Generous Positive Controls

If I repeat the training process from above but now include Staurosporine as a training control then the classifier is still capable of clearly separating the two categories.

```{r}
non_stauro_pos_controls = c("Bortezomib", "Irinotecan / SN-38")
valid_entries = features_metadata$DRUG == "Staurosporine_500nM" | 
  (features_metadata$DRUG %in% non_stauro_pos_controls & features_metadata$CONCENTRATION %in% c(0.2, 1))

features_pos = features[valid_entries, ]
features_neg = features[features_metadata$DRUG == "DMSO", ]

# Balance training samples
nsamples = min(nrow(features_pos), nrow(features_neg))
features_neg = features_neg[sample(seq_len(nrow(features_neg)), nsamples, replace = FALSE), ]
features_neg$TYPE = "NEG_CTRL"
features_pos = features_pos[sample(seq_len(nrow(features_pos)), nsamples, replace = FALSE), ]
features_pos$TYPE = "POS_CTRL"

# Combine into one dataframe
features_rf = rbind.data.frame(features_neg, features_pos)
features_rf$TYPE = as.factor(features_rf$TYPE)

# Split into training and testing data
test_indices = sample(seq_len(nrow(features_rf)), nrow(features_rf) * 0.25, replace = FALSE)
rf_train = features_rf[-test_indices, ]
rf_test = features_rf[test_indices, ]

# Run training and evaluation
rfmodel = randomForest(TYPE ~ ., data = rf_train)
ypredict = predict(object = rfmodel, rf_test)
print(table(ypredict, rf_test$TYPE))
```

Furthermore, if I train it on Staurosporine and both other positive controls as separate categories, then it can also cleanly separate these four categories. This means that it is crucial to properly define what a "dead" organoid is, as the variety between organoids, even between controls, is quite large.

```{r}
non_stauro_pos_controls = c("Bortezomib", "Irinotecan / SN-38")
valid_entries = features_metadata$DRUG %in% c("DMSO", "Staurosporine_500nM") |
  (features_metadata$DRUG %in% non_stauro_pos_controls & 
  features_metadata$CONCENTRATION %in% c(0.2, 1))

features_rf = features[valid_entries, ]
labels = features_metadata[valid_entries, "DRUG"]

# Balance training samples
nsamples = min(table(labels))
features_rf = do.call(
  rbind.data.frame, 
  lapply(unique(labels), function(x) {
    tmp = features_rf[labels == x, ]
    tmp = tmp[sample(seq_len(nrow(tmp)), nsamples, replace = FALSE), ]
    l = x
    if(x == "Irinotecan / SN-38") l = "Irinotecan"
    if(x == "Staurosporine_500nM") l = "Staurosporine"
    tmp$TYPE = l
    return(tmp)
  }))
features_rf$TYPE = as.factor(features_rf$TYPE)

# Split into training and testing data
test_indices = sample(seq_len(nrow(features_rf)), nrow(features_rf) * 0.5, replace = FALSE)
rf_train = features_rf[-test_indices, ]
rf_test = features_rf[test_indices, ]

# Run training and evaluation
rfmodel = randomForest(TYPE ~ ., data = rf_train)
ypredict = predict(object = rfmodel, rf_test)
print(table(as.character(ypredict), as.character(rf_test$TYPE)))
```