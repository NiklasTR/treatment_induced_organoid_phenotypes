---
title: "Organoid Viability"
author: "Jan Sauer"
date: "`r Sys.Date()`"
output: 
   BiocStyle::html_document:
    code_folding: hide
    df_print: paged
    toc_depth: 4
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Organoid Viability}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, message=FALSE}
library(ggplot2)
library(tidyverse)
library(knitr)
library(kableExtra)
library(reshape2)
library(pheatmap)
library(SCOPEMouse)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# Load data
data("organoid_viability", package = "SCOPEMouse")

# Define colors
full_color_scale = c(
  "#e6194b", "#3cb44b", "#ffe119", "#0082c8", "#f58231", 
  "#911eb4", "#46f0f0", "#f032e6", "#d2f53c", "#fabebe", 
  "#008080", "#e6beff", "#aa6e28", "#fffac8", "#800000", 
  "black", "darkgray", "lightgray", "white")

# Lines
lines = get_lines()
colorScale = setNames(
  object = full_color_scale[seq_along(lines)], 
  nm = lines)

# Define a base theme for the plots
# Modified from https://rpubs.com/Koundy/71792
theme_vignette <- function(base_size=14, base_family="Helvetica") {
  library(grid)
  library(ggthemes)
  (theme_foundation(base_size=base_size, base_family=base_family)
    + theme(plot.title = element_text(face = "bold",
                                      size = rel(1.2), hjust = 0.5), 
            plot.subtitle = element_text(hjust = 0.5),
            plot.caption = element_text(hjust = 0),
            text = element_text(),
            panel.background = element_rect(colour = NA),
            plot.background = element_rect(colour = NA),
            panel.border = element_rect(colour = NA),
            axis.title = element_text(face = "bold",size = rel(1)),
            axis.title.y = element_text(angle=90,vjust =2),
            axis.title.x = element_text(vjust = -0.2),
            axis.text = element_text(), 
            axis.line = element_line(colour="black"),
            axis.ticks = element_line(),
            # panel.grid.major = element_line(colour="#f0f0f0"),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            legend.key = element_rect(colour = NA),
            legend.position = "right",
            legend.direction = "vertical",
            legend.key.size= unit(0.5, "cm"),
            legend.spacing = unit(1, "cm"),
            legend.title = element_text(face="italic"),
            plot.margin=unit(c(10,5,5,5),"mm"),
            strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
            strip.text = element_text(face="bold")))
}

theme_vignette_color <- function(...){
  library(scales)
  discrete_scale(
    aesthetics = c("colour", "color"), scale_name = "theme_vignette",
    palette = manual_pal(values = unname(colorScale)), ...)
}

theme_vignette_fill <- function(...){
  library(scales)
  discrete_scale(
    aesthetics = c("fill"), scale_name = "theme_vignette",
    palette = manual_pal(values = unname(colorScale)), ...)
}

# Flag whether images should be saved additionally as PDF files
save_images = FALSE
img_output_dir = "images"
if(save_images) if(!dir.exists(img_output_dir)) dir.create(img_output_dir)

MOUSE_POS_CTRLS = c(
    "Bortezomib (PS-341)", "MLN2238", "CEP-18770 (Delanzomib)",
    "Dinaciclib (SCH727965)", "A-674563",
    "Fluvastatin Sodium", "Quisinostat (JNJ-26481585)", "AT13387")
```

# Introduction 
I trained a random forest classifier to differentiate between live and dead organoids. DMSO served as the negative controls, i.e. live organoids. After visual inspection of the images we decided to use the following drugs as positive controls:

```{r}
print(MOUSE_POS_CTRLS)
```

A separate classifier was trained for each cell line. Data was split into a training and validation data set.

# Classifier Validation and Quality Control
## Training Validation
The ROC curves of the classifiers on the validation data set as well as the corresponding AUROCs are shown below.
```{r}
ggplot(
    data = roc_data %>% filter(clf_line == data_line), 
    mapping = aes(x = FalsePosRate, y = TruePosRate, group = clf_line)) + 
  geom_line(size = 1, color = "black") + theme_vignette() + 
  scale_color_manual(values = colorScale) + 
  labs(x = "False Positive Rate", y = "True Positive Rate", 
       title = "Validation ROC Curves") + 
  coord_equal()
if(save_images) ggsave(
  filename = file.path(img_output_dir, "Validation_ROC.pdf"), 
  width = 4, height = 4, useDingbats = FALSE)
```

```{r}
ggplot(
    data = roc_aucs %>% filter(clf_line == data_line) %>% 
      mutate(texty = AUC - 0.075, text = round(AUC, 3)), 
    mapping = aes(x = clf_line, y = AUC)) + 
  geom_col() + 
  geom_text(aes(y = texty, label = text), color = "White") + 
  theme_vignette() + scale_color_manual(values = colorScale) + 
  coord_flip() + theme(axis.ticks = element_blank()) + 
  scale_y_continuous(breaks = c(0, 0.5, 1.0)) + 
  labs(x = "", y = "", title = "Validation AUROC")
if(save_images) ggsave(
  filename = file.path(img_output_dir, "Validation_AUC.pdf"), 
  height = 4, width = 3, useDingbats = FALSE)
```

## Replicate Correlation
I look at the correlation between replicates
```{r}
rep1 = mortality %>% 
  arrange(Replicate, Layout, Line, Well.ID) %>% 
  filter(Replicate == 1)
rep2 = mortality %>% 
  arrange(Replicate, Layout, Line, Well.ID) %>% 
  filter(Replicate == 2)
repcor_df = data.frame(
  "r1" = rep1$Percent.Live, 
  "r2" = rep2$Percent.Live, 
  "line" = rep1$Line)
ggplot(data = repcor_df, aes(x = r1, y = r2)) + 
  geom_point(alpha = 0.25, size = 0.1) + 
  theme_vignette() + scale_color_manual(values = colorScale) + 
  xlab("Replicate 1") + ylab("Replicate 2") + 
  ggtitle(
    label = "Viability Correlation between Replicates",
    subtitle = sprintf("rho =  %0.4f", cor(repcor_df$r1, repcor_df$r2))) + 
  theme(legend.position = "none") + coord_fixed()
if(save_images) ggsave(
  filename = file.path(img_output_dir, "ViabilityReplicateCorrelation.pdf"), 
  width = 4, height = 4, useDingbats = FALSE)
```

```{r}
line_cors_img = data.frame(
  "Line" = sort(unique(repcor_df$line)), 
  "Correlation" = NA, 
  row.names = sort(unique(repcor_df$line)), 
  stringsAsFactors = FALSE)
for(line in unique(repcor_df$line)) {
  line_cors_img[line, "Correlation"] = cor(
    repcor_df[repcor_df$line == line, "r1"], 
    repcor_df[repcor_df$line == line, "r2"])
}
line_cors_img$CorrLabel = sprintf("%0.2f", line_cors_img$Correlation)
line_cors_img$CorrLoc = line_cors_img$Correlation - 0.15

ggplot(data = line_cors_img, mapping = aes(x = Line, y = Correlation)) + 
  geom_col() + theme_vignette() + xlab("") + ylab("") + 
  geom_text(aes(x = Line, y = CorrLoc, label = CorrLabel), color = "White") + 
  coord_polar() + 
  theme(axis.text.y = element_blank(), axis.ticks = element_blank(), 
        axis.line = element_blank(), axis.text.x = element_text(size = 8)) + 
  ggtitle("Viability Correlation by Lines")
if(save_images) ggsave(
  filename = file.path(
    img_output_dir, "ViabilityReplicateCorrelation_bars_polar.pdf"),
  width = 7, height = 4, useDingbats = FALSE)
```

## Validation of Control Wells
```{r}
dmso_mortality = mortality %>% filter(Product.Name == "DMSO")
dmso_mortality_by_plate = aggregate(
  x = dmso_mortality$Percent.Live, 
  by = list(dmso_mortality$Plate.ID), 
  FUN = median)
colnames(dmso_mortality_by_plate) = c("Plate", "Viability")
dmso_mortality_by_plate$Line = substr(dmso_mortality_by_plate$Plate, 1, 7)
ggplot() + 
  geom_boxplot(
    data = dmso_mortality, 
    mapping = aes(x = Line, y = Percent.Live), 
    outlier.size = -1, fill = "lightgrey") + 
  geom_point(
    data = dmso_mortality_by_plate, 
    mapping = aes(x = Line, y = Viability)) + 
  theme_vignette() + labs(x = "", y = "") + 
  coord_cartesian(ylim = c(0.75, 1.0)) + 
  ggtitle(label = "Negative Control Viability per Line") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
if(save_images) ggsave(
  filename = file.path(img_output_dir, "NegCtrl_Viability.pdf"),
  width = 7, height = 4, useDingbats = FALSE)
```

```{r}
pos_mortality = mortality %>% filter(Product.Name %in% MOUSE_POS_CTRLS)
pos_mortality_by_plate = aggregate(
  x = pos_mortality$Percent.Live, 
  by = list(pos_mortality$Plate.ID), 
  FUN = median)
colnames(pos_mortality_by_plate) = c("Plate", "Viability")
pos_mortality_by_plate$Line = substr(pos_mortality_by_plate$Plate, 1, 7)
ggplot() + 
  geom_boxplot(
    data = pos_mortality, 
    mapping = aes(x = Line, y = Percent.Live), 
    outlier.size = -1, fill = "lightgrey") + 
  geom_point(
    data = pos_mortality_by_plate, 
    mapping = aes(x = Line, y = Viability)) + 
  theme_vignette() + labs(x = "", y = "") + 
  # coord_cartesian(ylim = c(0.75, 1.0)) + 
  ggtitle(label = "Positive Control Viability per Line") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
if(save_images) ggsave(
  filename = file.path(img_output_dir, "PosCtrl_Viability.pdf"),
  width = 7, height = 4, useDingbats = FALSE)
```

# Clustering by Viabilities
Having established the validity of the classifier and the screen quality, I attempt to cluster drugs based on the organoid viability. I explicitly keep the positive controls at the highest two concentrations
```{r}
drug_viability = mortality %>% 
  select(Product.Name, Line, Percent.Live)
drug_viability = aggregate(
  x = drug_viability$Percent.Live, 
  by = list("Drug" = drug_viability$Product.Name, 
            "Line" = drug_viability$Line), 
  FUN = mean)
drug_viability = acast(
  data = drug_viability, 
  formula = Drug ~ Line, 
  value.var = "x")
```

## Clustering all Drugs
```{r}
# corr = cor(t(drug_viability), use = "pairwise.complete.obs")
# d = as.dist((1 - corr)/2)
d = dist(drug_viability)
hc = hclust(d, method = "ward.D2")

hc_lines = hclust(dist(t(drug_viability)), method = "ward.D2")

# Annotate Pathway and Targets
annotation = drug_annotations[
  drug_annotations$Drug %in% rownames(drug_viability), ]
annotation[annotation$Drug == "DMSO", ] = c("DMSO", "DMSO", "DMSO")
for(drug in MOUSE_POS_CTRLS) annotation[annotation$Drug == drug, ] = rep(drug, 3)

pathways = list()
for(pathway in unique(annotation$Pathway)) {
  pathways[[pathway]] = grep(
    pattern = paste0("\\b", pathway, "\\b"), 
    x = annotation$Pathway, 
    ignore.case = TRUE)
}
pathways_sig_vec = get_cluster_enrichment(
  clustering = hc, labels = pathways, min_cluster_size = 5, 
  max_cluster_size = 50)
# 'Others' is too vague
pathways_sig_vec$Labels[pathways_sig_vec$Labels == "Others"] = NA

targets_split = tolower(annotation$Targets)
# Turn targets into list
targets = list()
for(target in unique(unlist(strsplit(targets_split, ", ")))) {
  targets[[target]] = grep(
    pattern = paste0("\\b", target, "\\b"), 
    x = targets_split, ignore.case = TRUE)
}
targets_sig_vec = get_cluster_enrichment(
  clustering = hc, labels = targets, 
  min_cluster_size = 5, max_cluster_size = 50)

ctrl_anno = rep(NA, nrow(annotation))
ctrl_anno[annotation$Drug == "DMSO"] = "DMSO"
ctrl_anno[annotation$Drug %in% MOUSE_POS_CTRLS] = "Pos. Ctrl"

annotation = data.frame(
  "Pathway" = pathways_sig_vec$Labels, 
  "Target" = targets_sig_vec$Labels, 
  "Control" = ctrl_anno,
  row.names = rownames(drug_viability), 
  stringsAsFactors = FALSE)

all_pathways = na.omit(unique(pathways_sig_vec$Labels))
all_targets = na.omit(unique(targets_sig_vec$Labels))
annotation_color = list(
  "Pathway" = setNames(
    object = unname(full_color_scale)[seq_along(all_pathways)], 
    nm = all_pathways), 
  "Target" = setNames(
    object = unname(full_color_scale)[seq_along(all_targets)], 
    nm = all_targets), 
  "Control" = setNames(
    object = unname(full_color_scale)[seq_along(c("DMSO", "Pos. Ctrl"))], 
    nm = c("DMSO", "Pos. Ctrl")))

hm_colorScale = colorRampPalette(
  rev(c("#f7f7f7", "#E0F3F8", "#91BFDB", "#4575B4")))(150)

pheatmap(
  mat = t(drug_viability), show_colnames = FALSE, show_rownames = TRUE,
  cluster_rows = hc_lines, cluster_cols = hc,
  annotation_col = annotation, color = hm_colorScale, 
  annotation_colors = annotation_color, clustering_method = "ward.D2",
  cutree_cols = 4, main = "Viability Clustering", 
  border_color = NA, cellwidth = 0.1, cellheight = 10)
if(save_images) pheatmap(
  mat = t(drug_viability), show_colnames = FALSE, show_rownames = TRUE,
  cluster_rows = hc_lines, cluster_cols = hc,
  annotation_col = annotation, color = hm_colorScale, 
  annotation_colors = annotation_color, main = "Viability Clustering",
  border_color = NA, cellwidth = 0.25, cellheight = 10, height = 10,
  filename = file.path(img_output_dir, "ViabilityDrugClustering_allDrugs.pdf"))
```

## Clustering Active drugs
Inactive drugs can be defined as those drugs, which cluster most closely to DMSO, i.e. the large, white block.
```{r}
# Isolate the active drugs by removing the cluster with DMSO
# 4 branches were determined from the plot above; more robust would be a 
# specific distance measure, but this would have the same outcome.
labels = cutree(hc, k = 3)
dmso_label = labels["DMSO"]
active_drug_viability = drug_viability[labels != dmso_label, ]
d_active = dist(active_drug_viability)
hc_active = hclust(d_active, method = "ward.D2")

annotation_color$Control = annotation_color$Control["Pos. Ctrl"]

pheatmap(
  mat = t(active_drug_viability), show_colnames = FALSE, show_rownames = TRUE,
  cluster_rows = hc_lines, cluster_cols = hc_active,
  annotation_col = annotation, color = hm_colorScale, 
  annotation_colors = annotation_color, clustering_method = "ward.D2",
  cutree_cols = 3, main = "Viability Clustering of Active Drugs",
  border_color = NA, cellwidth = 0.9, cellheight = 10)
if(save_images) pheatmap(
  mat = t(active_drug_viability), show_colnames = FALSE, show_rownames = TRUE,
  cluster_rows = hc_lines, cluster_cols = hc_active,
  annotation_col = annotation, color = hm_colorScale, 
  annotation_colors = annotation_color, clustering_method = "ward.D2",
  border_color = NA, cellwidth = 0.9, cellheight = 10, height = 10,
  cutree_cols = 3, main = "Viability Clustering of Active Drugs",
  filename = file.path(
    img_output_dir, "ViabilityDrugClustering_allDrugs_onlyActive.pdf"))
```

### Active Drugs 
```{r}
annotation[rownames(active_drug_viability), c("Pathway", "Target")] %>%
    kable(caption = "Active Drugs") %>%
    kable_styling(bootstrap_options = "condensed", full_width = FALSE) %>%
    row_spec(0, bold = TRUE)
```

### Individual Groups
I take a closer look at individual clusters for a more detailed view.

```{r}
find_smallest_common_cluster = function(clustering, elements) {
  # Set clusters
  clusters = list()
  for(ii in seq_len(nrow(clustering$merge))) {
    hcrow = clustering$merge[ii, ]
    if(hcrow[1] < 0) {
      set1 = clustering$labels[-1 * hcrow[1]]
    } else {
      set1 = clusters[[hcrow[1]]]
    }
    if(hcrow[2] < 0) {
      set2 = clustering$labels[-1 * hcrow[2]]
    } else {
      set2 = clusters[[hcrow[2]]]
    }
    clusters[[ii]] = c(set1, set2)
  }
  
  # Find smallest cluster that contains all 'elements'
  contains_all = sapply(clusters, function(x) all(elements %in% x))
  min_cluster = clusters[contains_all][[
    which.min(lengths(clusters[contains_all]))]]
  return(min_cluster)
}

# MEK Inhibitors
mek_inhibitors = rownames(drug_viability[which(annotation$Target == "mek"), ])
smallest_cluster = find_smallest_common_cluster(
  clustering = hc_active, elements = mek_inhibitors)
mek_cluster = drug_viability[smallest_cluster, ]
mek_anno = drug_annotations[drug_annotations$Drug %in% smallest_cluster, ]
rownames(mek_anno) = mek_anno$Drug
mek_anno$Drug = NULL

all_pathways = na.omit(unique(mek_anno$Pathways))
all_targets = na.omit(unique(mek_anno$Targets))
mek_anno_color = list(
  "Pathways" = setNames(
    object = unname(full_color_scale)[seq_along(all_pathways)], 
    nm = all_pathways), 
  "Targets" = setNames(
    object = unname(full_color_scale)[seq_along(all_targets)], 
    nm = all_targets))

pheatmap(
  mat = t(mek_cluster), show_colnames = TRUE, show_rownames = TRUE, 
  annotation_col = mek_anno, 
  cluster_rows = hc_lines, cluster_cols = TRUE, color = hm_colorScale, 
  annotation_colors = mek_anno_color, clustering_method = "ward.D2",
  border_color = NA, cellwidth = 10, cellheight = 10)
if(save_images) pheatmap(
  mat = t(mek_cluster), show_colnames = TRUE, show_rownames = TRUE,
  annotation_col = mek_anno, 
  cluster_rows = hc_lines, cluster_cols = TRUE, color = hm_colorScale, 
  annotation_colors = mek_anno_color, clustering_method = "ward.D2",
  border_color = NA, cellwidth = 10, cellheight = 10, height = 10,
  filename = file.path(
    img_output_dir, "ViabilityDrugClustering_allDrugs_onlyMEK.pdf"))

# EGFR Inhibitors
egfr_inhibitors = rownames(drug_viability[
  which(annotation$Target == "egfr"), ])
smallest_cluster = find_smallest_common_cluster(
  clustering = hc_active, elements = egfr_inhibitors)
egfr_cluster = drug_viability[smallest_cluster, ]
egfr_anno = drug_annotations[drug_annotations$Drug %in% smallest_cluster, ]
rownames(egfr_anno) = egfr_anno$Drug
egfr_anno$Drug = NULL

all_pathways = na.omit(unique(egfr_anno$Pathways))
all_targets = na.omit(unique(egfr_anno$Targets))
egfr_anno_color = list(
  "Pathways" = setNames(
    object = unname(full_color_scale)[seq_along(all_pathways)], 
    nm = all_pathways), 
  "Targets" = setNames(
    object = unname(full_color_scale)[seq_along(all_targets)], 
    nm = all_targets))

pheatmap(
  mat = t(egfr_cluster), show_colnames = TRUE, show_rownames = TRUE, 
  annotation_col = egfr_anno, 
  cluster_rows = hc_lines, cluster_cols = TRUE, color = hm_colorScale, 
  annotation_colors = egfr_anno_color, clustering_method = "ward.D2",
  border_color = NA, cellwidth = 10, cellheight = 10)
if(save_images) pheatmap(
  mat = t(egfr_cluster), show_colnames = TRUE, show_rownames = TRUE,
  annotation_col = egfr_anno, 
  cluster_rows = hc_lines, cluster_cols = TRUE, color = hm_colorScale, 
  annotation_colors = egfr_anno_color, clustering_method = "ward.D2",
  border_color = NA, cellwidth = 10, cellheight = 10, height = 10,
  filename = file.path(
    img_output_dir, "ViabilityDrugClustering_allDrugs_onlyEGFR.pdf"))

# MTOR Inhibitors
mtor_inhibitors = rownames(drug_viability[
  which(annotation$Target == "mtor"), ])
smallest_cluster = find_smallest_common_cluster(
  clustering = hc_active, elements = mtor_inhibitors)
mtor_cluster = drug_viability[smallest_cluster, ]
mtor_anno = drug_annotations[drug_annotations$Drug %in% smallest_cluster, ]
rownames(mtor_anno) = mtor_anno$Drug
mtor_anno$Drug = NULL

all_pathways = na.omit(unique(mtor_anno$Pathways))
all_targets = na.omit(unique(mtor_anno$Targets))
mtor_anno_color = list(
  "Pathways" = setNames(
    object = unname(full_color_scale)[seq_along(all_pathways)], 
    nm = all_pathways), 
  "Targets" = setNames(
    object = unname(full_color_scale)[seq_along(all_targets)], 
    nm = all_targets))

pheatmap(
  mat = t(mtor_cluster), show_colnames = TRUE, show_rownames = TRUE, 
  annotation_col = mtor_anno, 
  cluster_rows = hc_lines, cluster_cols = TRUE, color = hm_colorScale, 
  annotation_colors = mtor_anno_color, clustering_method = "ward.D2",
  border_color = NA, cellwidth = 10, cellheight = 10)
if(save_images) pheatmap(
  mat = t(mtor_cluster), show_colnames = TRUE, show_rownames = TRUE,
  annotation_col = mtor_anno, 
  cluster_rows = hc_lines, cluster_cols = TRUE, color = hm_colorScale, 
  annotation_colors = mtor_anno_color, clustering_method = "ward.D2",
  border_color = NA, cellwidth = 10, cellheight = 10, height = 10,
  filename = file.path(
    img_output_dir, "ViabilityDrugClustering_allDrugs_onlyMTOR.pdf"))
```

I center and scale the viabilities of the active drugs to visually determine if any drugs have distinctly differential effects.
```{r}
scaled_active_drug_viability = apply(
  X = t(active_drug_viability), 
  MARGIN = 2, FUN = function(x) 
    (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE))
limit = max(abs(range(scaled_active_drug_viability, na.rm = TRUE)))
z_breaks = seq(-limit, limit, length.out = 100)
hm_z_colorScale = colorRampPalette(
  c("#e6194b", "white", "#0082c8"))(length(z_breaks))
pheatmap(
  mat = scaled_active_drug_viability, show_colnames = FALSE,
  annotation_col = annotation, cluster_cols = hc_active,
  clustering_method = "ward.D2", 
  color = hm_z_colorScale, breaks = z_breaks, 
  annotation_colors = annotation_color,
  border_color = NA, cellheight = 10)
```

And z-scaled across rows
```{r}
scaled_active_drug_viability = t(apply(
  X = active_drug_viability, 
  MARGIN = 2, FUN = function(x) 
    (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)))
limit = max(abs(range(scaled_active_drug_viability, na.rm = TRUE)))
z_breaks = seq(-limit, limit, length.out = 100)
hm_z_colorScale = colorRampPalette(c("#e6194b", "white", "#0082c8"))(length(z_breaks))
pheatmap(
  mat = scaled_active_drug_viability, show_colnames = FALSE,
  annotation_col = annotation, cluster_cols = hc_active,
  clustering_method = "ward.D2", 
  color = hm_z_colorScale, breaks = z_breaks, 
  annotation_colors = annotation_color,
  border_color = NA, cellheight = 10)
```

## Average Line Response
Lines show similar average responses to drugs.
```{r}
line_response = data.frame(
  "Line" = colnames(active_drug_viability),
  "Viability" = apply(active_drug_viability, 2, median, na.rm = TRUE), 
  stringsAsFactors = FALSE)
line_response = line_response[order(line_response$Viability), ]
line_response$Line = factor(line_response$Line, levels = line_response$Line)
ggplot(data = line_response) + 
  geom_col(mapping = aes(x = Line, y = Viability)) + 
  theme_vignette() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  ggtitle("Median Viability of Organoids Treated With Active Drugs")
if(save_images) ggsave(
  filename = file.path(img_output_dir, "MedianResponseToActiveDrugs.pdf"), 
  width = 7, height = 4, useDingbats = FALSE)
```

# Transfer Learning Accuracy Metrics

I trained classifiers for each cell line individually and then measured its accuracy on the data of all other cell lines as well. This transfer learning matrix gives an idea of how similar the training data is for each cell line. The heatmap shows the accuracies of classifiers trained on individual cell lines (rows) when applied to the validation data of all cell lines (columns). Note that the same validation data for each cell line is used to test each classifier, making the results directly comparable.
```{r}
hm_colorScale = colorRampPalette(
  c("#f7f7f7", "#003399"))(150)
pheatmap(
  acc_matrix, cluster_rows = FALSE, cluster_cols = FALSE, 
  color = hm_colorScale, display_numbers = FALSE, 
  fontsize_number = 12, legend = TRUE, 
  main = "Transfer Accuracies", border_color = NA)
if(save_images) pheatmap(
  acc_matrix, cluster_rows = FALSE, cluster_cols = FALSE, 
  color = hm_colorScale, display_numbers = FALSE, 
  fontsize_number = 12, legend = TRUE, 
  filename = file.path(img_output_dir, "TransferLearningAccuracies.pdf"), 
  main = "Transfer Accuracies", cellwidth = 15, cellheight = 15, 
  border_color = NA)
```

ROC curves also give some insight into how well the classifiers can be applied to other cell lines. Shown below are the ROC curves for the classifiers of all lines on the data of all lines

```{r}
rocs = roc_data
rocs$LegendLabel = paste0(
  rocs$data_line, ": ", round(
    x = roc_aucs[match(rocs$data_line, roc_aucs$data_line), "AUC"], 
    digits = 3))
ggplot(data = rocs, 
       mapping = aes(x = FalsePosRate, y = TruePosRate, 
                     color = data_line)) + 
  geom_line() + facet_wrap(facets = ~clf_line) + 
  theme_vignette() + scale_color_manual(values = full_color_scale) + 
  coord_equal() +
  labs(color = "Data Line", x = "False Pos. Rate", y = "True Pos. Rate")
if(save_images) ggsave(
  filename = file.path(
    img_output_dir, 
    sprintf("TransferLearningAccuracies_roc_%s.pdf", clf_line)), 
  width = 5, height = 5, useDingbats = FALSE)
```

# Classifiers Trained on Reduced Feature Sets

The same viability classifier can be trained on limited feature sets. I attempted to train the classifier using only features relating to specific channels (Actin, DAPI, FITC, and Actin + DAPI). 

## Correlation to Full Dataset
I begin by looking at the correlation between the results of these "reduced classifiers" and the classifiers trained on the full feature sets. The two-channel classifier trained on the Actin and DAPI channels correlates most strongly with the full classifier.
```{r}
ggplot_df = data.frame(
  "All.Channels" = mortality$Percent.Live, 
  "Actin" = mortality_reduced$Actin$Percent.Live, 
  "DAPI" = mortality_reduced$DAPI$Percent.Live, 
  "FITC" = mortality_reduced$FITC$Percent.Live,
  "ActinDAPI" = mortality_reduced$Actin_DAPI$Percent.Live)

ggplot(data = ggplot_df, aes(x = All.Channels, y = Actin)) + 
  geom_point(alpha = 0.3, size = 0.5) + 
  theme_vignette() + scale_color_manual(values = colorScale(length(lines))) + 
  xlab("All Channels") + ylab("Only Actin Channel") + 
  ggtitle(label = "All Channels versus Actin Channel", 
          subtitle = sprintf(
            "Correlation: %0.4f", cor(ggplot_df$All.Channels, ggplot_df$Actin))) + 
  theme(legend.key.size = unit(0.5, "cm"), legend.position = "right", 
        legend.direction = "vertical") + coord_equal() + 
  geom_line(data = data.frame("x" = c(0,1), "y" = c(0,1)), mapping = aes(x = x, y = y), 
            size = 2, color = "red")
if(save_images) ggsave(
  filename = file.path(img_output_dir, "ReducedClassifierCorrelation_vsActin.pdf"), 
  width = 4, height = 4, useDingbats = FALSE)

ggplot(data = ggplot_df, aes(x = All.Channels, y = DAPI)) + 
  geom_point(alpha = 0.3, size = 0.5) + 
  theme_vignette() + scale_color_manual(values = colorScale(length(lines))) + 
  xlab("All Channels") + ylab("Only DAPI Channel") + 
  ggtitle(label = "All Channels versus DAPI Channel", 
          subtitle = sprintf(
            "Correlation: %0.4f", cor(ggplot_df$All.Channels, ggplot_df$DAPI))) + 
  theme(legend.key.size = unit(0.5, "cm"), legend.position = "right", 
        legend.direction = "vertical") + coord_equal() + 
  geom_line(data = data.frame("x" = c(0,1), "y" = c(0,1)), mapping = aes(x = x, y = y), 
            size = 2, color = "red")
if(save_images) ggsave(
  filename = file.path(img_output_dir, "ReducedClassifierCorrelation_vsDAPI.pdf"), 
  width = 4, height = 4, useDingbats = FALSE)

ggplot(data = ggplot_df, aes(x = All.Channels, y = FITC)) + 
  geom_point(alpha = 0.3, size = 0.5) + 
  theme_vignette() + scale_color_manual(values = colorScale(length(lines))) + 
  xlab("All Channels") + ylab("Only FITC Channel") + 
  ggtitle(label = "All Channels versus FITC Channel", 
          subtitle = sprintf(
            "Correlation: %0.4f", cor(ggplot_df$All.Channels, ggplot_df$FITC))) + 
  theme(legend.key.size = unit(0.5, "cm"), legend.position = "right", 
        legend.direction = "vertical") + coord_equal() + 
  geom_line(data = data.frame("x" = c(0,1), "y" = c(0,1)), mapping = aes(x = x, y = y), 
            size = 2, color = "red")
if(save_images) ggsave(
  filename = file.path(img_output_dir, "ReducedClassifierCorrelation_vsFITC.pdf"), 
  width = 4, height = 4, useDingbats = FALSE)

ggplot(data = ggplot_df, aes(x = All.Channels, y = ActinDAPI)) + 
  geom_point(alpha = 0.3, size = 0.5) + 
  # geom_hex(bins = 100, color = "black") + 
  theme_vignette() + scale_color_manual(values = colorScale(length(lines))) + 
  xlab("All Channels") + ylab("Actin+Dapi Channels") + 
  ggtitle(label = "All Channels versus Actin+DAPI Channels", 
          subtitle = sprintf(
            "Correlation: %0.4f", cor(ggplot_df$All.Channels, ggplot_df$ActinDAPI))) + 
  theme(legend.position = "none") + coord_equal() + 
  geom_line(data = data.frame("x" = c(0,1), "y" = c(0,1)), mapping = aes(x = x, y = y), 
            size = 2, color = "red")
if(save_images) ggsave(
  filename = file.path(img_output_dir, "ReducedClassifierCorrelation_vsActinDAPI.pdf"), 
  width = 4, height = 4, useDingbats = FALSE)
```

## Accuracy Comparison
A barplot for the accuracies of classifiers on their native datasets. While there is a substantial drop in accuracy for most cell lines if only individual channels are used, the classifier does not become useless. The lowest achieved accuracy if only the DAPI channel is used is still approximately 80%, which is reasonable for a biological screen. It is worth noting that the additional stainings possible by using only one of the channels and freeing up the other two will undoubtedly improve the accuracy again.

```{r}
acc_full = diag(acc_matrix)
acc_Actin = diag(acc_matrix_reduced$Actin)
acc_FITC = diag(acc_matrix_reduced$FITC)
acc_DAPI = diag(acc_matrix_reduced$DAPI)
acc_ActinDAPI = diag(acc_matrix_reduced$Actin_DAPI)

acc = cbind(acc_full, acc_Actin, acc_DAPI, acc_FITC, acc_ActinDAPI)
acc = reshape2::melt(acc)
colnames(acc) = c("Line", "Type", "Accuracy")
acc$Split = setNames(
  rep(c("A", "B", "C"), each = 5), 
  sort(unique(acc$Line)))[acc$Line]
acc$Line = as.character(acc$Line)

ggplot(data = acc) + 
  geom_col(aes(x = Line, y = Accuracy, fill = Type), 
           position = position_dodge()) + 
  facet_wrap(facets = ~Line, nrow = 3, scales = "free_x") + 
  theme_vignette() + scale_fill_manual(
    labels = c("All Channels", "Actin", "DAPI", "Dead Cells", "Actin + DAPI"), 
    values = c("#800000", "#e6194b", "#0082c8", "#3cb44b", "#911eb4")) + 
  labs(x = "", y = "", fill = "") + theme(
    legend.key.size = unit(0.5, "cm")) + 
  coord_cartesian(ylim = c(0.7, 1.0)) + 
  theme(strip.background = element_blank(), strip.text = element_blank()) + 
  ggtitle(
    label = "Accuracies of Classifiers", 
    subtitle = "Classifiers were Trained on a Subset of Image Channels")
if(save_images) ggsave(
  filename = file.path(img_output_dir, "ReducedClassifierAccuracies.pdf"), 
  width = 6, height = 4, useDingbats = FALSE)
```

```{r, fig.height=4, fig.width=7}
ggplot_df = acc
ggplot_df$Type = c(
  "acc_full" = "All", 
  "acc_Actin" = "Actin", 
  "acc_DAPI" = "DAPI", 
  "acc_FITC" = "FITC", 
  "acc_ActinDAPI" = "Actin & DAPI")[ggplot_df$Type]
ggplot_df$Type = factor(x = ggplot_df$Type, levels = c("All", "Actin", "DAPI", "FITC", "Actin & DAPI"))
ggplot(data = ggplot_df, mapping = aes(x = Type, y = Accuracy, fill = Type)) + 
  geom_boxplot(position = position_dodge(), width = 0.5) + 
  geom_point(position = position_jitterdodge(jitter.width = 0.5)) + 
  theme_vignette() + scale_fill_manual(
    labels = c("All Channels", "Actin", "DAPI", "Dead Cells", "Actin + DAPI"), 
    values = c("#800000", "#e6194b", "#0082c8", "#3cb44b", "#911eb4"))
if(save_images) ggsave(
  filename = file.path(img_output_dir, "ReducedClassifierAccuracies_boxplot.pdf"), 
  width = 6, height = 3, useDingbats = FALSE)
```
